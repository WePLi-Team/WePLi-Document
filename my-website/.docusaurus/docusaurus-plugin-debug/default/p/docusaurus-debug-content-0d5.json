{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/docs","tagsPath":"/docs/tags","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs","editUrlLocalized":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/i18n/en/docusaurus-plugin-content-docs/current","isLast":true,"routePriority":-1,"sidebarFilePath":"/Users/dongh/Documents/WePLi-Document/my-website/sidebars.ts","contentPath":"/Users/dongh/Documents/WePLi-Document/my-website/docs","contentPathLocalized":"/Users/dongh/Documents/WePLi-Document/my-website/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"intro","title":"개요","description":"WePLi는 사람들이 음악을 통해 서로의 취향을 공유하고, 함께 플레이리스트를 만들어가는 소셜 음악 서비스입니다.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"서비스 소개","permalink":"/docs/service-introduce"}},{"id":"service-introduce","title":"서비스 소개","description":"서비스 목표","source":"@site/docs/service-introduce.md","sourceDirName":".","slug":"/service-introduce","permalink":"/docs/service-introduce","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/service-introduce.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"개요","permalink":"/docs/intro"},"next":{"title":"기술 스택","permalink":"/docs/category/기술-스택"}},{"id":"Softwrare Requirements Specification/appendices","title":"5. Appendices","description":"- Spotify API Documentation","source":"@site/docs/Softwrare Requirements Specification/appendices.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/appendices","permalink":"/docs/Softwrare Requirements Specification/appendices","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/appendices.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"4. Interface Requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements"}},{"id":"Softwrare Requirements Specification/interface-requirements","title":"4. Interface Requirements","description":"4.1 User Interfaces","source":"@site/docs/Softwrare Requirements Specification/interface-requirements.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/interface-requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/interface-requirements.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"3. Specific Requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements"},"next":{"title":"5. Appendices","permalink":"/docs/Softwrare Requirements Specification/appendices"}},{"id":"Softwrare Requirements Specification/introduction","title":"1. Introduction","description":"1.1 Purpose","source":"@site/docs/Softwrare Requirements Specification/introduction.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/introduction","permalink":"/docs/Softwrare Requirements Specification/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"소프트웨어 요구사항 명세서 (SRS)","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"},"next":{"title":"2. Overall Description","permalink":"/docs/Softwrare Requirements Specification/overall-description"}},{"id":"Softwrare Requirements Specification/overall-description","title":"2. Overall Description","description":"2.1 Product Perspective","source":"@site/docs/Softwrare Requirements Specification/overall-description.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/overall-description","permalink":"/docs/Softwrare Requirements Specification/overall-description","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/overall-description.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"1. Introduction","permalink":"/docs/Softwrare Requirements Specification/introduction"},"next":{"title":"3. Specific Requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements"}},{"id":"Softwrare Requirements Specification/specific-requirements","title":"3. Specific Requirements","description":"3.1 Functional Requirements","source":"@site/docs/Softwrare Requirements Specification/specific-requirements.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/specific-requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/specific-requirements.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"2. Overall Description","permalink":"/docs/Softwrare Requirements Specification/overall-description"},"next":{"title":"4. Interface Requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","title":"제안 검색어 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"키워드로 노래 검색하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx"},"next":{"title":"2-2. Responses","permalink":"/docs/category/2-2-responses"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","title":"키워드로 노래 검색하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Search","permalink":"/docs/category/search"},"next":{"title":"제안 검색어 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","title":"노래 정보 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Song","permalink":"/docs/category/song"},"next":{"title":"ID로 여러 곡 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","title":"ID로 여러 곡 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"노래 정보 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx"},"next":{"title":"Search","permalink":"/docs/category/search"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","title":"Album","description":"Artist 객체는 앨범의 아티스트를 나타내는 리소스 개체로, 아티스트는 한 명 이상의 사람이 될 수 있습니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Artist","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"},"next":{"title":"Search","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","title":"Artist","description":"Artist 객체는 Apple Music API에서 아티스트에 대한 정보를 제공합니다. 다음은 Artist 객체의 속성과 그 설명입니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Songs","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx"},"next":{"title":"Album","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","title":"Search","description":"Artist 객체는 앨범의 아티스트를 나타내는 리소스 개체로, 아티스트는 한 명 이상의 사람이 될 수 있습니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Album","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"},"next":{"title":"2. 데이터베이스","permalink":"/docs/기술 스택/database-scheme"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","title":"Songs","description":"Song 객체는 Apple Music API에서 곡에 대한 정보를 제공합니다. 다음은 Song 객체의 속성과 그 설명입니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"2-2. Responses","permalink":"/docs/category/2-2-responses"},"next":{"title":"Artist","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"}},{"id":"기술 스택/API Docs/tech-stack","title":"1. Info","description":"1. Apple Music API","source":"@site/docs/기술 스택/API Docs/tech-stack.md","sourceDirName":"기술 스택/API Docs","slug":"/기술 스택/API Docs/tech-stack","permalink":"/docs/기술 스택/API Docs/tech-stack","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/tech-stack.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"1. API","permalink":"/docs/category/1-api"},"next":{"title":"2. Apple Music API Docs","permalink":"/docs/category/2-apple-music-api-docs"}},{"id":"기술 스택/database-scheme","title":"2. 데이터베이스","description":"WePLi 서비스는 사용자가 자신만의 음악 플레이리스트를 만들고, 다른 사용자와 공유할 수 있는 플랫폼입니다.","source":"@site/docs/기술 스택/database-scheme.md","sourceDirName":"기술 스택","slug":"/기술 스택/database-scheme","permalink":"/docs/기술 스택/database-scheme","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/database-scheme.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Search","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"},"next":{"title":"3. 버전","permalink":"/docs/기술 스택/versions"}},{"id":"기술 스택/versions","title":"3. 버전","description":"이 문서에서는 각 기술 스택과 관련 도구의 버전을 명확히 설명합니다.","source":"@site/docs/기술 스택/versions.md","sourceDirName":"기술 스택","slug":"/기술 스택/versions","permalink":"/docs/기술 스택/versions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/versions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"2. 데이터베이스","permalink":"/docs/기술 스택/database-scheme"},"next":{"title":"소프트웨어 요구사항 명세서 (SRS)","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"}}],"drafts":[],"sidebars":{"tutorialSidebar":[{"type":"doc","id":"intro"},{"type":"doc","id":"service-introduce"},{"type":"category","label":"기술 스택","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"1. API","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/tech-stack"},{"type":"category","label":"2. Apple Music API Docs","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"2-1. Requests","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Song","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx"}],"link":{"type":"generated-index","description":"노래 관련 API를 보기 쉽게 정리한 문서입니다.","slug":"/category/song","permalink":"/docs/category/song"}},{"type":"category","label":"Search","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx"}],"link":{"type":"generated-index","description":"검색 관련 API를 보기 쉽게 정리한 문서입니다.","slug":"/category/search","permalink":"/docs/category/search"}}],"link":{"type":"generated-index","description":"Apple Music API 중 필요한 요청을 보기 쉽게 정리한 문서입니다.","slug":"/category/2-1-requests","permalink":"/docs/category/2-1-requests"}},{"type":"category","label":"2-2. Responses","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/2-2-responses","permalink":"/docs/category/2-2-responses"}}],"link":{"type":"generated-index","description":"Apple Music API 내용을 보기 쉽게 정리한 문서입니다.","slug":"/category/2-apple-music-api-docs","permalink":"/docs/category/2-apple-music-api-docs"}}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/1-api","permalink":"/docs/category/1-api"}},{"type":"doc","id":"기술 스택/database-scheme"},{"type":"doc","id":"기술 스택/versions"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/기술-스택","permalink":"/docs/category/기술-스택"}},{"type":"category","label":"소프트웨어 요구사항 명세서 (SRS)","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"Softwrare Requirements Specification/introduction"},{"type":"doc","id":"Softwrare Requirements Specification/overall-description"},{"type":"doc","id":"Softwrare Requirements Specification/specific-requirements"},{"type":"doc","id":"Softwrare Requirements Specification/interface-requirements"},{"type":"doc","id":"Softwrare Requirements Specification/appendices"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/소프트웨어-요구사항-명세서-srs","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"}}]}}]}},"docusaurus-plugin-content-blog":{"default":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"가짜 로딩을 활용하는 방법","metadata":{"permalink":"/blog/가짜 로딩을 활용하는 방법","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-02-12/2025-02-12-Wepli-UX.mdx","source":"@site/blog/2025-02-12/2025-02-12-Wepli-UX.mdx","title":"가짜 로딩을 통해 사용자 기대감 향상시키기","description":"이번 글에서는 WePLi에서 가짜 로딩(Fake Loading)을 활용하게 된 계기와 이를 통해 얻은 UX적 개선 효과에 대해 이야기하려 합니다.","date":"2025-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"UI","permalink":"/blog/tags/ui"},{"inline":true,"label":"UX","permalink":"/blog/tags/ux"},{"inline":true,"label":"Fake Loading","permalink":"/blog/tags/fake-loading"}],"readingTime":13.175,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"가짜 로딩을 활용하는 방법","title":"가짜 로딩을 통해 사용자 기대감 향상시키기","authors":["donghyeon"],"tags":["WePLi","UI","UX","Fake Loading"]},"unlisted":false,"nextItem":{"title":"음악 API를 찾고 활용하기까지의 과정","permalink":"/blog/Apple Music API 사용기"}},"content":"import Admonition from '@theme/Admonition';\nimport NameCardFlow from './명함 만들기 플로우.png';\nimport LoadingGraph from './01_로딩시간그래프.png';\nimport LoadingGif from './Screen_Recording_20250212_235117_WePLi.gif';\n\n이번 글에서는 WePLi에서 가짜 로딩(Fake Loading)을 활용하게 된 계기와 이를 통해 얻은 UX적 개선 효과에 대해 이야기하려 합니다.\n\n<!-- truncate -->\n\n### 🎯 문제 인식\n\n<img src={NameCardFlow} alt=\"NameCardFlow\"/>\n<br/>\n\n최근 WePLi에서 사용자의 취향이 반영된 명함을 생성하고 공유할 수 있는 기능을 개발하고 있었습니다.  \n\n이 기능은 사용자가 입력한 정보를 기반으로 명함을 즉시 생성하는 방식이었는데, 개발을 완료한 후 실제로 테스트해 보니 예상보다 밋밋한 느낌이 들었습니다.\n\n<br/>\n\n### ❓ 왜 그렇게 느껴졌을까?\n\n명함 생성 과정은 기술적으로 보면 완벽하고 단순했습니다.\n1. 사용자가 정보를 입력하고 버튼을 누르면,\n2. 미리 정의된 템플릿에 데이터를 채워서\n3. 바로 명함을 보여주면 끝.\n\n그런데 **사용 경험(UX)** 측면에서는 뭔가 부족함이 있었습니다.  \n\n입력한 정보들이 너무 빠르게 명함으로 변환되면서, 사용자는 **내가 무언가를 만들어낸 느낌**을 받지 못했습니다.\n어떤 데이터를 입력하든 순식간에 결과물이 나와버리니 감흥이 적었고, 그 과정에서 특별한 기대감도 형성되지 않았습니다.\n\n즉, 기능적으로는 문제가 없지만 UX적으로는 임팩트가 부족한 상태였습니다.\n이를 해결하기 위해 \"가짜 로딩\"을 추가해 사용자 경험을 개선할 수 있겠다는 생각을 하게 되었습니다.\n\n<br/>\n\n### 🤔 가짜 로딩을 추가하면 뭐가 좋을까?\n\n보통 로딩은 최대한 줄여야 하는 요소입니다. 하지만, 일부러 로딩을 추가하는 것이 UX 개선에 도움이 될 수도 있습니다.\n\n#### 1. 사용자의 기대감을 높인다.\n\n우리는 \"빠르면 좋다\"라고 생각하지만, 너무 빨리 끝나면 그만큼 감동도 덜합니다.  \n\n예를 들어, 영화에서 중요한 반전이 순식간에 지나가 버린다면 긴장감이 덜한 것처럼,\n**\"무언가 특별한 작업이 진행되고 있다\"** 는 느낌은 사용자에게 기대감을 갖게 만듭니다.\n\n명함을 만드는 동안 몇 초의 대기 시간은 기대감을 높이는 역할을 합니다.  \n**“어떤 명함이 나올까?“** 라는 궁금증이 UX를 더 깊이 있게 만들어 줍니다.\n\n#### 2. 명함이 단순한 데이터 조합이 아니라, 더 정교한 작업처럼 보이도록 만든다.\n\n기술적으로 보면 명함 생성은 즉시 끝낼 수 있습니다.\n하지만 사용자는 너무 빠르면 허술해 보인다고 느낄 수도 있습니다.  \n> 🤖 AI가 0.1초 만에 질문에 답변을 했다면 \"정확한 답변인가?\"라는 의문이 들지 않나요?\n\n<br/>\n가짜 로딩을 추가하면서 진행률을 실시간으로 보여준다면, 사용자는 \"내 명함이 좀 더 특별한 방식으로 만들어지고 있구나\"라고 인식하게 될 것 입니다.\n\n<br/>\n<br/>\n\n### ⏳ 총 로딩 시간 결정하기\n\n가짜 로딩을 통해서 사용자의 기대감을 향상시키는 것은 좋으나, 사용자를 지루하게 만들면 안됩니다.  \n즉, 의도적인 로딩을 추가할 때 **얼마나 오래 보여줄 것인가**를 정해야합니다.\n\n우선 사용자에게 답답함을 주지 않으면서 기대감을 심어줄 수 있는 최적의 시간을 찾기 위해 **로딩 시간에 따른 이탈률**에 관해 조사를 해보았습니다.\n\n\n<div align=\"center\" width=\"100px\">\n    <img src={LoadingGraph} alt=\"Loading\" style={{width: 450}} />\n    <p style={{ fontSize: \"0.85rem\", color: \"#6c757d\", textAlign: \"center\" }}>\n        로딩 시간에 따른 사용자 이탈률 (자료=Google / SOASTA Research, 2017)\n    </p>\n</div>\n\n\n- 1초 이하 : 사용자는 로딩을 거의 인지하지 못함. 기대감 상승 효과 없음\n- 1~2초 : 사용자가 \"무언가 생성되고 있다\"는 느낌을 받을 수 있는 최소한의 시간\n- 3초 이상 : 사용자가 로딩을 부담스럽게 느끼며, 3초를 넘어서면 이탈률이 급증하는 경향이 있음.\n\n자료에 따르면 로딩이 너무 짧으면 사용자가 충분히 인지하지 못하고, 너무 길면 지루함을 느껴 이탈할 수 있습니다.\n특히 3초 이상부터는 이탈률이 급격하게 증가합니다.  \n\n위의 조사롤 통해 처음에는 **최소 1초 이상, 3초 이내로 로딩을 유지하는 것이 적절**하다고 판단했습니다.  \n\n<br/>\n<br/>\n\n**🛠 초기 로딩 시간 설정 및 테스트**\n\n그래서 약 2초로 로딩 시간을 설정하고 개발을 진행한 후, 지인들을 대상으로 테스트를 진행해 보았습니다.\n\n<Admonition type=\"danger\" icon=\"🧑‍💻\" title=\"테스터들의 반응:\">\n- “생각보다 너무 빨리 끝나서, 로딩이 주는 임팩트가 약한 것 같다.”\n- “명함을 만드는 기능인데, 너무 짧아서 뭔가 휙 지나가 버리는 느낌이다.”\n</Admonition>\n\n👉 결론: 2초는 사용자에게 “명함이 만들어지고 있다”는 느낌을 주기엔 너무 짧음\n\n<br/>\n\n**🛠 3~4초로 조정 후 추가 테스트 진행**\n\n이후 로딩 시간을 3~4초로 조정하여 다시 테스트를 진행했습니다.\n\n<Admonition type=\"success\" icon=\"🧑‍💻\" title=\"테스터들의 반응:\">\n- “프로그레스 바가 실시간으로 올라가는 게 보여서 자연스러웠다.”\n- “숫자가 증가하는 애니메이션이 있어서 3~4초가 지루하게 느껴지진 않았다.”\n- “명함을 만드는 기능이라면, 이 정도 로딩 시간은 필요하다고 생각한다.”\n</Admonition>\n\n👉 결론: 3~4초 정도의 시간이 사용자가 ‘기다림’을 충분히 인식하면서도, 지루함을 느끼지 않는 최적의 시간으로 판단\n\n<br/>\n\n테스트 결과, 2초 이하는 기대감을 주기엔 너무 짧은 시간이었습니다.  \n애니메이션과 진행률 표시가 있더라도, **“명함이 만들어지는 과정”** 을 체감하기엔 부족했습니다.\n\n반면, **3초 ~ 4초** 정도의 로딩 시간을 적용했을 때는\n- 사용자가 충분히 ‘기다림’을 인식하면서도\n- 지루함을 느끼지 않는 최적의 경험을 제공할 수 있었습니다.\n\n결과적으로, 명함 만들기 기능의 가짜 로딩 시간은 약 **3초 ~ 4초**로 설정하였습니다.  \n\n<br/>\n<br/>\n\n### 🚀 로딩 애니메이션 설계\n\n가짜 로딩을 효과적으로 활용하려면 단순히 기다리는게 아니라, **자연스럽게 몰입할 수 있도록 설계하는 것이 중요**합니다.  \n잘못된 가짜 로딩은 오히려 사용자에게 **시간을 끌고 있다**는 인상을 줄 수 있기 때문에 주의해야합니다.\n\n이를 위해, 개발 전에 명확한 UX 요구사항을 정의하고, 이를 반영하여 로딩 애니메이션을 구현하였습니다.\n\n**📝 가짜 로딩 요구 사항**\n- 사용자가 로딩을 인지할 수 있어야한다. (최소 1초 이상 유지)\n- 사용자가 지루함을 느껴서는 안된다. (최대 3초 이하)  \n   → 3초를 넘어서면 이탈률이 증가할 가능성이 있음  \n   → 적절한 애니메이션을 활용하면 체감 시간을 줄일 수 있음  \n- 사용자가 가짜 로딩인 것을 모르게 해야한다.  \n   → 일정하게 증가하는 것이 아닌 비선형적으로 증가해야함\n- 사용자가 현재 진행 상황을 명확하게 알 수 있어야한다.  \n   → 진행률을 표시해 예측 가능하게 만들어야 함\n\n\n**💡 구현 방법**\n- 3초 이전: 로딩 진행률을 랜덤하게 증가시키며, 일반적인 프로그레스 바처럼 동작\n- 3초 이후: 최소 증가량을 높여 빠르게 마무리하도록 조정\n- 딜레이를 랜덤하게 조정하여 불규칙한 진행 느낌을 줌  \n\n\n**📌 코드 구현 (비선형 증가 및 랜덤 딜레이 적용)**\n\n```kotlin\nwhile (state.makeCardProgress < 1.0f) {\n   val elapsedTime = System.currentTimeMillis() - startTime\n\n   reduce {\n      // 3초 이후에는 최소 증가량을 높여 더 빠르게 진행\n      val minIncrement = if (elapsedTime >= 3000L) 0.15 else 0.05\n      val randomIncrement = Random.nextDouble(minIncrement, 0.25).toFloat()\n      val progress = (state.makeCardProgress + randomIncrement)\n\n      state.updateProgress(progress)\n   }\n\n   // 3초 이후에는 딜레이를 줄여서 빠르게 마무리\n   val delayTime = if (elapsedTime >= 3000L) {\n      Random.nextLong(100L, 200L) // 3초 이후에는 짧은 딜레이 적용\n   } else {\n      Random.nextLong(250L, 750L) // 3초 이전까지는 기존 딜레이 유지\n   }\n\n   delay(delayTime)\n}\n```\n\n<br/>\n\n**🎭 UI 애니메이션 적용**\n> 프로그레스 바와 숫자가 자연스럽게 증가 되도록 하였습니다.\n\n```kotlin\nval animatedProgress by animateFloatAsState(\n   targetValue = state.makeCardProgress,\n   animationSpec = tween(durationMillis = 250, easing = LinearOutSlowInEasing),\n   label = \"Animated Progress\"\n)\n\nGradientLinearProgressBar(progress = animatedProgress)\n```\n\n<br/>\n<br/>\n<br/>\n\n### 🎯 결론: 가짜 로딩이 사용자 경험에 미치는 영향\n<img src={LoadingGif} alt=\"Loading\" style={{width: 200,  display: \"block\", margin: \"0 auto\"}} />  \n\n<br/>\n\n이번 경험을 통해 단순히 빠르게 결과를 보여주는 것이 최고의 UX가 아닐 수도 있다는 점을 다시금 확인할 수 있었습니다.  \n적절한 기다림은 사용자의 기대감을 높이고, 결과를 더욱 특별하게 느끼게 하는 요소가 될 수 있습니다.\n\n이제는 단순히 **“최대한 빠르게”** 가 아니라, **“사용자가 몰입할 수 있는 최적의 속도”** 를 고민하는 것이 중요한 시대인 것 같습니다.\n가짜 로딩이 단순한 시간 지연이 아니라, UX를 향상시키는 중요한 도구가 될 수 있다는 점을 기억하며 앞으로도 다양한 기능에 적용해볼 계획입니다.\n\n오늘도 긴 글 읽어주셔서 감사합니다. 😊"},{"id":"Apple Music API 사용기","metadata":{"permalink":"/blog/Apple Music API 사용기","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-12-29/2024-12-29.mdx","source":"@site/blog/2024-12-29/2024-12-29.mdx","title":"음악 API를 찾고 활용하기까지의 과정","description":"이 글에서는 WePLi에서 음악 API를 선택하고 활용한 과정을 소개합니다.","date":"2024-12-29T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"Apple Music API","permalink":"/blog/tags/apple-music-api"},{"inline":true,"label":"Spotify API","permalink":"/blog/tags/spotify-api"},{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app"}],"readingTime":6.595,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"Apple Music API 사용기","title":"음악 API를 찾고 활용하기까지의 과정","authors":["donghyeon"],"tags":["WePLi","Apple Music API","Spotify API","MusicApp"]},"unlisted":false,"prevItem":{"title":"가짜 로딩을 통해 사용자 기대감 향상시키기","permalink":"/blog/가짜 로딩을 활용하는 방법"},"nextItem":{"title":"WePLi를 개발하게 된 이유","permalink":"/blog/WePLi를 개발하게 된 이유"}},"content":"<!-- truncate -->\n\n이 글에서는 WePLi에서 음악 API를 선택하고 활용한 과정을 소개합니다.  \n특히 Apple Music API를 선택한 이유와 활용 예시를 중점으로 다룰 예정입니다.\n\n### 음악 데이터 구축의 필요성\n\n음악 관련 서비스에서 음악 검색 기능은 필수적인 요소입니다.  \n하지만 개인이 1억 개 이상의 곡과 지속적으로 추가되는 신곡 데이터를 직접 구축하는 것은 현실적으로 어렵습니다.\n\nWePLi의 초기 버전(Java Swing)에서는 여러 음악 플랫폼의 인기 차트를 통합하여 제공하는 기능을 고려했었습니다. 하지만 국내 플랫폼(멜론, 지니, 벅스 등)은 공식적인 API를 제공하지 않아, 크롤링을 이용해야 했습니다.\n\n<div align=\"center\">\n    ![검색 화면 예시](./wepli_chart_screen.png)\n    <p align=\"center\">\n        WePLi(Java Swing) 차트 화면\n    </p>\n</div>\n\n당시에는 서비스 배포 계획이 없었기 때문에 크롤링 방식이 문제가 되지 않았지만, 현재의 WePLi 앱은 공식적으로 배포될 예정이므로 안정적이고 법적 문제가 없는 공식 API가 필요했습니다.\n\n이 글에서는 음악 API를 선택하는 과정과 고려 사항을 정리하고, Apple Music API를 어떻게 활용했는지 소개하겠습니다.\n\n<br/>\n\n### 음악 API 선택 시 고려했던 것들\n\nWePLi는 단순 음악 검색 기능뿐만 아니라 사용자 간 공유, 게시글에 노래 첨부 등 다양한 기능을 제공합니다.\n이러한 기능을 구현하기 위해 적절한 음악 API를 찾기 시작했습니다.\n\n![검색 화면 예시](./search_screen.png)\n\n음악 API를 선택할 때 고려한 기준은 다음과 같습니다.\n\n- **필수 조건**\n   - 검색 기능 제공  \n   - 한국 노래 지원  \n   - 무료 또는 저렴한 비용\n   <br/>\n- **부가 조건**\n   - 추천 서비스 제공(검색어, 플레이리스트 등)  \n\n\n위 조건으로 API를 찾던 중, 가장 흔히 사용되는 API 서비스 2개가 눈에 들어왔습니다.\n\n- Spotify API [[링크]](https://developer.spotify.com/terms)\n- Apple Music API [[링크]](https://developer.apple.com/documentation/applemusicapi)\n\n<br/>\n\n### Spotify API vs Apple Music API 비교\n\n|                 |   Spotify   | Apple Music |\n|-----------------|-------------|-------------|\n| 검색 기능 제공 여부 | O            | O           |\n| 국내 노래 제공 여부 | X (영어로 제공) | O           |\n| 가격             | 무료          | 연 13만원     |\n\nSpotify API는 방대한 데이터와 무료라는 큰 장점이 있지만, 국내 노래가 한글로 지원 되지 않는다는 큰 단점이 있었습니다.\n아무래도 국내보단 해외에서 많이 사용되는 서비스이기 때문에 가수들이 노래를 등록할 때 영어로 등록을 많이 하는 것 같습니다.\n\n\n#### Spotify API의 단점\n1. 한국 노래가 영어로 등록되어 있음 -> 검색 및 사용자 경험 저하\n2. Spotify 로그인이 필수 -> Spotify를 사용하지 않는 유저에겐 허들로 느껴질 수 있음\n\nWePLi의 주요 타깃층은 **국내 트렌드에 민감한 10-20대** 사용자입니다.  \n10-20대가 주 타깃층인 앱에서 대부분의 노래가 영어로만 제공이 된다면 **앱의 매력이 크게 감소할 것**이라 판단했습니다.\n\n결과적으로 **조금 더 완성도 높은 사용자 경험을 제공하기 위해** 연 13만원의 비용을 지불하더라도 Apple Music API를 선택하였습니다.\n\n<br/>\n\n### Apple Music API 활용\n\nWePLi에선 Apple Music API를 활용하여 다음과 같은 기능을 구현했습니다.\n\n1. **음악 검색 기능**\n   - 사용자가 원하는 노래를 검색하면, Apple Music API에서 제목, 아티스트, 앨범, 썸네일 이미지 등을 가져옵니다.\n   - 검색 결과를 기반으로 사용자가 쉽게 곡을 추가하고 공유할 수 있도록 UI를 구성했습니다.\n   <br/>\n2. **인기 차트**\n   - Apple Music의 인기 차트 데이터를 가져와 실시간으로 트렌드 곡을 제공합니다.\n   - 사용자가 현재 인기 있는 곡을 쉽게 확인할 수 있도록 구현되었습니다.\n   <br/>\n3. **인기 검색어**\n   - Apple Music API를 활용해 사용자들이 많이 검색하는 키워드를 분석하여 제공하는 기능입니다.\n   - 이를 통해 사용자는 현재 유행하는 음악을 쉽게 찾을 수 있습니다.\n\n<br/>\n\n### 마무리\n\nWePLi는 사용자 경험을 최우선으로 고려하여 Apple Music API를 선택했습니다.  \n비용적인 부담은 있지만, 보다 완성도 높은 음악 검색 및 공유 기능을 제공할 수 있다는 점에서 충분히 가치 있는 선택이라고 판단했습니다.\n\n앞으로도 API를 활용한 기능을 확장하면서, 더 나은 사용자 경험을 제공할 계획입니다.  \n다음 글에서는 Apple Music API를 실제로 적용한 코드 및 구현 방법을 상세히 다뤄보겠습니다.\n\n긴 글 읽어주셔서 감사합니다 🎵"},{"id":"WePLi를 개발하게 된 이유","metadata":{"permalink":"/blog/WePLi를 개발하게 된 이유","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-12-28-WePLi를 개발하게 된 이유.mdx","source":"@site/blog/2024-12-28-WePLi를 개발하게 된 이유.mdx","title":"WePLi를 개발하게 된 이유","description":"음악은 단순히 듣는 것에서 그치지 않고, 사람들과의 연결과 감정을 공유하는 매개체로서 강력한 힘을 가집니다.","date":"2024-12-28T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app"}],"readingTime":4.395,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"WePLi를 개발하게 된 이유","title":"WePLi를 개발하게 된 이유","authors":["donghyeon"],"tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"음악 API를 찾고 활용하기까지의 과정","permalink":"/blog/Apple Music API 사용기"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"음악은 단순히 듣는 것에서 그치지 않고, 사람들과의 연결과 감정을 공유하는 매개체로서 강력한 힘을 가집니다.  \n그렇기에 저는 음악과 관련된 프로젝트를 통해 이런 가치를 담아내고 싶다는 열망을 품게 되었습니다.\n\n이 글에서는 **WePLi**를 개발하게 된 계기와 과정을 소개합니다.\n\n<!-- truncate -->\n\n<br/>\n\n### 음악과 관련된 프로젝트를 만들고 싶다는 열망\n\n음악은 항상 제 삶에서 큰 영감을 주는 요소였습니다.   \n특히 기존의 음악 앱들은 단순히 음악을 듣는 것을 넘어 사용자 경험과 트렌디한 디자인으로 저를 매료시켰습니다.\n\n이로 인해 **\"내가 만든 음악 앱은 어떤 모습일까?\"** 라는 생각이 자연스럽게 떠올랐고,   \n**WePLi** 프로젝트를 시작하는 계기가 되었습니다.\n\n<br/>\n\n### 디자인에 대한 욕심\n\n저는 개발자이지만, 늘 디자인에도 관심이 많았습니다.   \n기능적인 완성도는 기본이고, 이를 뒷받침하는 매력적인 디자인이야말로 프로젝트를 돋보이게 한다고 생각합니다.\n\n하지만 대학 시절 디자이너와 협업을 하면서 제 취향을 반영한 결과물을 만드는 것이 얼마나 어려운 일인지 깨달았습니다.   \n원하는 디자인을 말로 설명하는 것도 쉽지 않았고, 협업의 특성상 제 의견만을 고집할 수는 없었기 때문입니다.\n\n이후 회사에서도 기획서와 기존 디자인에 기반하여 개발을 진행하다 보니, 제가 **원하는 기능과 디자인을 온전히 담은 앱**을 만들어야겠다는 생각이 더욱 커져 **WePLi**를 개발하게 되었습니다.\n\n<br/>\n\n### 내 취향이 담긴 앱, WePLi의 탄생\n\n사실 **WePLi**라는 앱은 완전히 새로운 시작은 아니었습니다.   \n과거 Java Swing을 사용해 동일한 주제의 프로그램([Github](https://github.com/DeuWePLi/WePLi))을 만들어본 적이 있었습니다.\n\n\n당시에도 이 프로젝트는 제 취향을 가득 담아낸 결과물이라 큰 애정을 가졌었으나 기술적 한계로 인해 미완성으로 남겼던 아쉬움이 늘 마음에 남아 있었습니다.\n\n이번에는 성장한 제 개발 능력과 디자인 감각을 최대한으로 동원하여, 그때의 아쉬움을 해소하고 제가 진정으로 만들고 싶었던 앱을 완성하고자 WePLi를 시작했습니다.\n\n<br/>\n\n---\n\n**WePLi**는 단순한 앱이 아니라, 저의 개발 철학과 디자인에 대한 열정을 담은 프로젝트입니다.    \n음악이라는 주제를 통해 저만의 취향을 표현하면서도 사용자들에게 공감과 재미를 줄 수 있는 서비스를 만들고자 했습니다.\n\n앞으로 이 사이트를 통해 프로젝트를 완성하기까지의 과정과 시행착오 그리고 배운 점들을 기록하고 공유하고자 합니다.\n\n**WePLi**가 단순히 개인의 프로젝트를 넘어, 음악을 사랑하는 사람들이 서로의 취향을 공유하고 공감할 수 있는 공간이 되기를 바랍니다."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.465,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"WePLi를 개발하게 된 이유","permalink":"/blog/WePLi를 개발하게 된 이유"},"nextItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\n\nHere are a few tips you might find useful.\n\n<!-- truncate -->\n\nSimply add Markdown files (or folders) to the `blog` directory.\n\nRegular blog authors can be added to `authors.yml`.\n\nThe blog post date can be extracted from filenames, such as:\n\n- `2019-05-30-welcome.md`\n- `2019-05-30-welcome/index.md`\n\nA blog post folder can be convenient to co-locate blog post images:\n\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\n\nThe blog supports tags as well!\n\n**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."},{"id":"mdx-blog-post","metadata":{"permalink":"/blog/mdx-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-01-mdx-blog-post.mdx","source":"@site/blog/2021-08-01-mdx-blog-post.mdx","title":"MDX Blog Post","description":"Blog posts support Docusaurus Markdown features, such as MDX.","date":"2021-08-01T00:00:00.000Z","tags":[{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.235,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}],"frontMatter":{"slug":"mdx-blog-post","title":"MDX Blog Post","authors":["slorber"],"tags":["docusaurus"]},"unlisted":false,"prevItem":{"title":"Welcome","permalink":"/blog/welcome"},"nextItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).\n\n:::tip\n\nUse the power of React to create interactive blog posts.\n\n:::\n\n{/* truncate */}\n\nFor example, use JSX to create an interactive button:\n\n```js\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n<button onClick={() => alert('button clicked!')}>Click me!</button>"},{"id":"long-blog-post","metadata":{"permalink":"/blog/long-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-long-blog-post.md","source":"@site/blog/2019-05-29-long-blog-post.md","title":"Long Blog Post","description":"This is the summary of a very long blog post,","date":"2019-05-29T00:00:00.000Z","tags":[{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":2.06,"hasTruncateMarker":true,"authors":[{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"long-blog-post","title":"Long Blog Post","authors":"yangshun","tags":["hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"This is the summary of a very long blog post,\n\nUse a `<!--` `truncate` `-->` comment to limit blog post size in the list view.\n\n<!-- truncate -->\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"}],"blogListPaginated":[{"items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유","welcome","mdx-blog-post","long-blog-post"],"metadata":{"permalink":"/blog","page":1,"postsPerPage":10,"totalPages":1,"totalCount":6,"blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/blog/tags/we-p-li":{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li","items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유"],"pages":[{"items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유"],"metadata":{"permalink":"/blog/tags/we-p-li","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/ui":{"inline":true,"label":"UI","permalink":"/blog/tags/ui","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/ui","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/ux":{"inline":true,"label":"UX","permalink":"/blog/tags/ux","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/ux","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/fake-loading":{"inline":true,"label":"Fake Loading","permalink":"/blog/tags/fake-loading","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/fake-loading","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/apple-music-api":{"inline":true,"label":"Apple Music API","permalink":"/blog/tags/apple-music-api","items":["Apple Music API 사용기"],"pages":[{"items":["Apple Music API 사용기"],"metadata":{"permalink":"/blog/tags/apple-music-api","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/spotify-api":{"inline":true,"label":"Spotify API","permalink":"/blog/tags/spotify-api","items":["Apple Music API 사용기"],"pages":[{"items":["Apple Music API 사용기"],"metadata":{"permalink":"/blog/tags/spotify-api","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/music-app":{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app","items":["Apple Music API 사용기","WePLi를 개발하게 된 이유"],"pages":[{"items":["Apple Music API 사용기","WePLi를 개발하게 된 이유"],"metadata":{"permalink":"/blog/tags/music-app","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/facebook":{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description","items":["welcome"],"pages":[{"items":["welcome"],"metadata":{"permalink":"/blog/tags/facebook","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/hello":{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description","items":["welcome","long-blog-post"],"pages":[{"items":["welcome","long-blog-post"],"metadata":{"permalink":"/blog/tags/hello","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/docusaurus":{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description","items":["welcome","mdx-blog-post","long-blog-post"],"pages":[{"items":["welcome","mdx-blog-post","long-blog-post"],"metadata":{"permalink":"/blog/tags/docusaurus","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/blog/tags","authorsMap":{"donghyeon":{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"},"yangshun":{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"},"slorber":{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}}},"techblog":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"wepli-tech-blog-supabase-json","metadata":{"permalink":"/techblog/wepli-tech-blog-supabase-json","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/2025-02-01/wepli-tech-blog-supabase-json.mdx","source":"@site/techblog/2025-02-01/wepli-tech-blog-supabase-json.mdx","title":"Supabase Json으로 계층 구현하기","description":"Supabase를 사용하면서 View를 사용했을 때의 문제점을 소개합니다.","date":"2025-02-01T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":7.3,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog-supabase-json","title":"Supabase Json으로 계층 구현하기","authors":["donghyeon"],"date":"2025-02-01","tags":["WePLi","MusicApp"]},"unlisted":false,"nextItem":{"title":"WePLi 기술 블로그 소개","permalink":"/techblog/wepli-tech-blog"}},"content":"Supabase를 사용하면서 View를 사용했을 때의 문제점을 소개합니다.\n\n<br/>\n<br/>\n{/* truncate */}\n\nWePLi는 현재 서버 프레임워크 없이 Supabase만을 활용해 개발 중입니다.  \n\nSupabase는 서버가 없는 동안 임시 대체제로 사용되고 있으며, 추후 실제 서버로 전환할 예정입니다.  \n**Supabase를 서버로 전환할 때 앱에는 최대한 영향이 없어야한다는 목표**를 가지고 개발에 임하고 있습니다.\n\n앱에 영향이 없으려면 Supabae에서 실제 서버의 응답 구조와 비슷하게 구성을 해야하는데,  \n여기서 한 가지 문제점이 존재합니다.  \n\n관계형 데이터베이스는 기본적으로 **평면적인 테이블 구조**를 사용하기 때문에 **계층 데이터를 표현하기 어렵습니다.**  \n이로 인해 Supabase의 응답 형식과 실제 서버의 응답 구조 사이에 차이가 발생하며, 이 차이가 클수록 실제 서버 전환 시 앱 코드 수정 사항이 많아집니다.\n\n이 글에서는 기존 View 방식의 한계와, **PostgreSQL**의 ***JSON Aggregation*** 기능을 활용하여 계층형 데이터 뷰를 구성하는 방법을 소개합니다.\n\n\n### 기존 View 생성 방식과 그 한계\n\n일반적으로 View를 생성할 때는 여러 테이블을 JOIN하여 단순한 평면(Flat) 구조의 데이터를 반환합니다.\n\n예를 들어, **게시글(post)** 에 **작성자(user)** 와 **수록곡(song)** 정보를 함께 포함시키는 경우, 아래와 같이 View를 정의할 수 있습니다.\n\n```sql\nCREATE VIEW post_view AS\n  SELECT\n    p.id AS post_id,\n    p.title AS post_title,\n    p.contents AS post_contents,\n    u.id AS post_author_id,\n    u.email AS post_author_email,\n    u.username AS post_author_nickname,\n    u.profile_img AS post_author_profile_img,\n    s.song_id AS song_id,\n    s.title AS song_title,\n    s.artist_name AS song_artist,\n    s.album AS song_album,\n    s.cover_img AS song_cover,\n    s.href AS song_href,\n    s.duration_millis AS song_duration\nFROM posts p\n  LEFT JOIN public.user u ON p.author = u.id\n  LEFT JOIN post_bside_track pbt ON p.id = pbt.post_id\n  LEFT JOIN song s ON pbt.song_id = s.id;\n```\n\n<br/>\n\n### 주요 문제점\n\n1. 계층적 데이터 표현의 부재\n\n    ![image](./image_1.png)\n\n    - 게시글 하나에 여러 수록곡(song)이 포함되어 있으면, 각각의 수록곡마다 게시글 정보가 반복되어 반환됩니다.  \n      예시) 게시글 1에 수록곡 3개가 있다면, 동일한 게시글 정보가 3번 반복됨\n\n\n2. 네트워크 사용량 증가\n    - 데이터가 중복되어 전송되므로, 네트워크 사용량과 클라이언트 메모리 부담이 증가하며, 안드로이드 앱에서 파싱 및 가공하는 과정이 복잡해집니다.\n\n3. 서버 마이그레이션 및 API 변경 시 추가 공수 발생\n    - 서버 API는 일반적으로 계층적 구조로 데이터를 제공하므로, 이후 실제 서버로 마이그레이션시 수정이 불가피합니다.\n\n\n### Json Aggregation을 활용한 계층형 View 생성 방식\n\n관계형 DB에서 계층 구조로 데이터를 표현하는 방법 중 하나는 JSON을 이용하는 것입니다.\n\nPostgreSQL의 JSON 함수(json_agg, json_build_object)를 활용하면 데이터베이스에서 미리 계층형 구조의 데이터를 만들어 클라이언트에 전달할 수 있습니다.\n\n#### 구현 예시\n\n아래 코드는 각 게시글에 포함된 수록곡 정보를 JSON 배열로 집계하여, 게시글과 작성자 정보와 함께 계층형 데이터를 반환하는 View를 생성하는 예시입니다.\n\n```sql\nCREATE OR REPLACE VIEW post_tree_view as\n  WITH song_agg AS (\n    SELECT\n      pbt.post_id,\n      json_agg(\n        json_build_object(\n          'song_id', s.id,\n          'title', s.title,\n          'artist_name', s.artist_name,\n          'album', s.album,\n          'cover_img', s.cover_img,\n          'href', s.href,\n          'duration_millis', s.duration_millis\n        )\n      ) AS song_list\n    FROM post_bside_track pbt\n    LEFT JOIN song s ON pbt.song_id = s.id\n    GROUP BY pbt.post_id\n  )\n  SELECT\n    p.id AS post_id,\n    p.title AS post_title,\n    p.contents AS post_contents,\n    json_build_object(\n      'id', u.id,\n      'email', u.email,\n      'username', u.username,\n      'profile_img', u.profile_img\n    ) AS \"user\",\n    COALESCE(s.song_list, '[]'::json) AS song_list\n  FROM posts p\n  LEFT JOIN public.user u ON p.author = u.id\n  LEFT JOIN song_agg s ON p.id = s.post_id;\n\n```\n\n\n**실제 출력 결과**\n\n![image.png](./image_2.png)\n\n리스트 형태의 데이터가 Json으로 하나의 필드에 포함된 것을 볼 수 있습니다.  \n이렇게 불필요한 데이터 반복을 줄이고 필요한 데이터만 출력이 가능합니다.\n\n**예시 응답 결과**\n\n```json\n{\n  \"post_id\": 1,\n  \"post_title\": \"게시글 제목\",\n  \"post_contents\": \"게시글 내용\",\n  \"user\": {\n     \"id\": 123,\n     \"email\": \"user@example.com\",\n     \"username\": \"작성자닉네임\",\n     \"profile_img\": \"이미지 URL\"\n  },\n  \"song_list\": [\n     {\n       \"song_id\": 10,\n       \"title\": \"노래 제목\",\n       \"artist_name\": \"아티스트 이름\",\n       \"album\": \"앨범명\",\n       \"cover_img\": \"커버 이미지 URL\",\n       \"href\": \"노래 링크\",\n       \"duration_millis\": 210000\n     },\n     ...\n  ]\n}\n```\n\n\n### 안드로이드 입장에서의 Json 기반 View 활용 장점\n\n1. 네트워크 효율성 (데이터 전송 최적화)\n    - 중복 데이터 전송이 줄어들어 데이터 사용량이 절감됨\n    - 네트워크 비용 측면(데이터 사용량)에서도 효율적\n\n2. 응답 매핑 로직 간소화\n    - Domain 모델의 구조와 API 응답 구조가 비슷할수록 매핑 로직이 간소화 됨\n    - 평면 데이터에서 계층 구조로의 재구성이 필요 없으므로 개발 생산성이 향상됨\n\n3. 유지보수 및 확장성\n\t- 서버 API 변경이나 마이그레이션 시, 계층형 데이터 구조를 유지함으로써 클라이언트 코드 변경 부담이 줄어듦\n\n\n\n### 결론\n\nSupabase와 PostgreSQL의 JSON Aggregation 기능을 활용하여 계층형 데이터를 미리 구성함으로써, 안드로이드 앱 개발에서 네트워크 최적화 및 클라이언트 로직 단순화라는 이점을 얻을 수 있었습니다.\n\n서버 대신 Supabase를 이용해서 개발을 하시는 분들이 있다면 해당 글을 참고해서 활용해보시면 좋을 것 같습니다."},{"id":"wepli-tech-blog","metadata":{"permalink":"/techblog/wepli-tech-blog","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/intro.mdx","source":"@site/techblog/intro.mdx","title":"WePLi 기술 블로그 소개","description":"해당 블로그는 WePLi 개발 과정 중 기술적인 부분에 대해서 작성하기 위한 페이지입니다.","date":"2024-12-31T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":0.18,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog","title":"WePLi 기술 블로그 소개","authors":["donghyeon"],"date":"2024-12-31","tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"Supabase Json으로 계층 구현하기","permalink":"/techblog/wepli-tech-blog-supabase-json"}},"content":"해당 블로그는 WePLi 개발 과정 중 기술적인 부분에 대해서 작성하기 위한 페이지입니다.\n\n{/* truncate */}"}],"blogListPaginated":[{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog","page":1,"postsPerPage":2,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/techblog/tags/we-p-li":{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li","items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"pages":[{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog/tags/we-p-li","page":1,"postsPerPage":2,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/techblog/tags/music-app":{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app","items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"pages":[{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog/tags/music-app","page":1,"postsPerPage":2,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/techblog/tags","authorsMap":{"donghyeon":{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}}}},"docusaurus-plugin-content-pages":{"default":[{"type":"jsx","permalink":"/","source":"@site/src/pages/index.tsx"},{"type":"mdx","permalink":"/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don't need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-theme-classic":{},"docusaurus-tailwindcss":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}