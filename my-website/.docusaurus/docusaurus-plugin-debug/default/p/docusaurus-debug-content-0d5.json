{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/docs","tagsPath":"/docs/tags","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs","editUrlLocalized":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/i18n/en/docusaurus-plugin-content-docs/current","isLast":true,"routePriority":-1,"sidebarFilePath":"/Users/dongh/Documents/WePLi-Document/my-website/sidebars.ts","contentPath":"/Users/dongh/Documents/WePLi-Document/my-website/docs","contentPathLocalized":"/Users/dongh/Documents/WePLi-Document/my-website/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","title":"제안 검색어 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"키워드로 노래 검색하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx"},"next":{"title":"2-2. Responses","permalink":"/docs/category/2-2-responses"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","title":"키워드로 노래 검색하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Search","permalink":"/docs/category/search"},"next":{"title":"제안 검색어 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","title":"노래 정보 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Song","permalink":"/docs/category/song"},"next":{"title":"ID로 여러 곡 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","title":"ID로 여러 곡 조회하기","description":"설명","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API","slug":"/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"노래 정보 조회하기","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx"},"next":{"title":"Search","permalink":"/docs/category/search"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","title":"Album","description":"Artist 객체는 앨범의 아티스트를 나타내는 리소스 개체로, 아티스트는 한 명 이상의 사람이 될 수 있습니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Artist","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"},"next":{"title":"Search","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","title":"Artist","description":"Artist 객체는 Apple Music API에서 아티스트에 대한 정보를 제공합니다. 다음은 Artist 객체의 속성과 그 설명입니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Songs","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx"},"next":{"title":"Album","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","title":"Search","description":"Artist 객체는 앨범의 아티스트를 나타내는 리소스 개체로, 아티스트는 한 명 이상의 사람이 될 수 있습니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Album","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"},"next":{"title":"2. 데이터베이스","permalink":"/docs/기술 스택/database-scheme"}},{"id":"기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","title":"Songs","description":"Song 객체는 Apple Music API에서 곡에 대한 정보를 제공합니다. 다음은 Song 객체의 속성과 그 설명입니다.","source":"@site/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx.md","sourceDirName":"기술 스택/API Docs/Apple Music Docs/Responses","slug":"/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"2-2. Responses","permalink":"/docs/category/2-2-responses"},"next":{"title":"Artist","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"}},{"id":"기술 스택/API Docs/tech-stack","title":"1. Info","description":"1. Apple Music API","source":"@site/docs/기술 스택/API Docs/tech-stack.md","sourceDirName":"기술 스택/API Docs","slug":"/기술 스택/API Docs/tech-stack","permalink":"/docs/기술 스택/API Docs/tech-stack","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/API Docs/tech-stack.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"1. API","permalink":"/docs/category/1-api"},"next":{"title":"2. Apple Music API Docs","permalink":"/docs/category/2-apple-music-api-docs"}},{"id":"기술 스택/database-scheme","title":"2. 데이터베이스","description":"WePLi 서비스는 사용자가 자신만의 음악 플레이리스트를 만들고, 다른 사용자와 공유할 수 있는 플랫폼입니다.","source":"@site/docs/기술 스택/database-scheme.md","sourceDirName":"기술 스택","slug":"/기술 스택/database-scheme","permalink":"/docs/기술 스택/database-scheme","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/database-scheme.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Search","permalink":"/docs/기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"},"next":{"title":"3. 버전","permalink":"/docs/기술 스택/versions"}},{"id":"기술 스택/versions","title":"3. 버전","description":"이 문서에서는 각 기술 스택과 관련 도구의 버전을 명확히 설명합니다.","source":"@site/docs/기술 스택/versions.md","sourceDirName":"기술 스택","slug":"/기술 스택/versions","permalink":"/docs/기술 스택/versions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/기술 스택/versions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"2. 데이터베이스","permalink":"/docs/기술 스택/database-scheme"},"next":{"title":"소프트웨어 요구사항 명세서 (SRS)","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"}},{"id":"intro","title":"개요","description":"WePLi는 사람들이 음악을 통해 서로의 취향을 공유하고, 함께 플레이리스트를 만들어가는 소셜 음악 서비스입니다.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"서비스 소개","permalink":"/docs/service-introduce"}},{"id":"service-introduce","title":"서비스 소개","description":"서비스 목표","source":"@site/docs/service-introduce.md","sourceDirName":".","slug":"/service-introduce","permalink":"/docs/service-introduce","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/service-introduce.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"개요","permalink":"/docs/intro"},"next":{"title":"기술 스택","permalink":"/docs/category/기술-스택"}},{"id":"Softwrare Requirements Specification/appendices","title":"5. Appendices","description":"- Spotify API Documentation","source":"@site/docs/Softwrare Requirements Specification/appendices.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/appendices","permalink":"/docs/Softwrare Requirements Specification/appendices","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/appendices.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"4. Interface Requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements"}},{"id":"Softwrare Requirements Specification/interface-requirements","title":"4. Interface Requirements","description":"4.1 User Interfaces","source":"@site/docs/Softwrare Requirements Specification/interface-requirements.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/interface-requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/interface-requirements.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"3. Specific Requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements"},"next":{"title":"5. Appendices","permalink":"/docs/Softwrare Requirements Specification/appendices"}},{"id":"Softwrare Requirements Specification/introduction","title":"1. Introduction","description":"1.1 Purpose","source":"@site/docs/Softwrare Requirements Specification/introduction.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/introduction","permalink":"/docs/Softwrare Requirements Specification/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"소프트웨어 요구사항 명세서 (SRS)","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"},"next":{"title":"2. Overall Description","permalink":"/docs/Softwrare Requirements Specification/overall-description"}},{"id":"Softwrare Requirements Specification/overall-description","title":"2. Overall Description","description":"2.1 Product Perspective","source":"@site/docs/Softwrare Requirements Specification/overall-description.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/overall-description","permalink":"/docs/Softwrare Requirements Specification/overall-description","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/overall-description.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"1. Introduction","permalink":"/docs/Softwrare Requirements Specification/introduction"},"next":{"title":"3. Specific Requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements"}},{"id":"Softwrare Requirements Specification/specific-requirements","title":"3. Specific Requirements","description":"3.1 Functional Requirements","source":"@site/docs/Softwrare Requirements Specification/specific-requirements.md","sourceDirName":"Softwrare Requirements Specification","slug":"/Softwrare Requirements Specification/specific-requirements","permalink":"/docs/Softwrare Requirements Specification/specific-requirements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Softwrare Requirements Specification/specific-requirements.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"2. Overall Description","permalink":"/docs/Softwrare Requirements Specification/overall-description"},"next":{"title":"4. Interface Requirements","permalink":"/docs/Softwrare Requirements Specification/interface-requirements"}}],"drafts":[],"sidebars":{"tutorialSidebar":[{"type":"doc","id":"intro"},{"type":"doc","id":"service-introduce"},{"type":"category","label":"기술 스택","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"1. API","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/tech-stack"},{"type":"category","label":"2. Apple Music API Docs","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"2-1. Requests","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Song","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_a_catalog_song.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Song-API/get_multiple_catalog_songs_by_id.mdx"}],"link":{"type":"generated-index","description":"노래 관련 API를 보기 쉽게 정리한 문서입니다.","slug":"/category/song","permalink":"/docs/category/song"}},{"type":"category","label":"Search","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/search_for_catalog_resources.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Requests/Search-API/get_catalog_search_suggestions.mdx"}],"link":{"type":"generated-index","description":"검색 관련 API를 보기 쉽게 정리한 문서입니다.","slug":"/category/search","permalink":"/docs/category/search"}}],"link":{"type":"generated-index","description":"Apple Music API 중 필요한 요청을 보기 쉽게 정리한 문서입니다.","slug":"/category/2-1-requests","permalink":"/docs/category/2-1-requests"}},{"type":"category","label":"2-2. Responses","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/song-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/artist-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/album-response.mdx"},{"type":"doc","id":"기술 스택/API Docs/Apple Music Docs/Responses/search-response.mdx"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/2-2-responses","permalink":"/docs/category/2-2-responses"}}],"link":{"type":"generated-index","description":"Apple Music API 내용을 보기 쉽게 정리한 문서입니다.","slug":"/category/2-apple-music-api-docs","permalink":"/docs/category/2-apple-music-api-docs"}}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/1-api","permalink":"/docs/category/1-api"}},{"type":"doc","id":"기술 스택/database-scheme"},{"type":"doc","id":"기술 스택/versions"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/기술-스택","permalink":"/docs/category/기술-스택"}},{"type":"category","label":"소프트웨어 요구사항 명세서 (SRS)","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"Softwrare Requirements Specification/introduction"},{"type":"doc","id":"Softwrare Requirements Specification/overall-description"},{"type":"doc","id":"Softwrare Requirements Specification/specific-requirements"},{"type":"doc","id":"Softwrare Requirements Specification/interface-requirements"},{"type":"doc","id":"Softwrare Requirements Specification/appendices"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/소프트웨어-요구사항-명세서-srs","permalink":"/docs/category/소프트웨어-요구사항-명세서-srs"}}]}}]}},"docusaurus-plugin-content-blog":{"default":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"가짜 로딩을 활용하는 방법","metadata":{"permalink":"/blog/가짜 로딩을 활용하는 방법","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-02-12/2025-02-12-Wepli-UX.mdx","source":"@site/blog/2025-02-12/2025-02-12-Wepli-UX.mdx","title":"가짜 로딩을 통해 사용자 기대감 향상시키기","description":"이번 글에서는 WePLi에서 가짜 로딩(Fake Loading)을 활용하게 된 계기와 이를 통해 얻은 UX적 개선 효과에 대해 이야기하려 합니다.","date":"2025-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"UI","permalink":"/blog/tags/ui"},{"inline":true,"label":"UX","permalink":"/blog/tags/ux"},{"inline":true,"label":"Fake Loading","permalink":"/blog/tags/fake-loading"}],"readingTime":13.095,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"가짜 로딩을 활용하는 방법","title":"가짜 로딩을 통해 사용자 기대감 향상시키기","authors":["donghyeon"],"tags":["WePLi","UI","UX","Fake Loading"]},"unlisted":false,"nextItem":{"title":"음악 API를 찾고 활용하기까지의 과정","permalink":"/blog/Apple Music API 사용기"}},"content":"import Admonition from '@theme/Admonition';\nimport NameCardFlow from './namecard_flow.png';\nimport LoadingGraph from './loading_graph.png';\nimport LoadingGif from './Screen_Recording_20250212_235117_WePLi.gif';\n\n이번 글에서는 WePLi에서 가짜 로딩(Fake Loading)을 활용하게 된 계기와 이를 통해 얻은 UX적 개선 효과에 대해 이야기하려 합니다.\n\n<!-- truncate -->\n\n### 🎯 문제 인식\n\n<img src={NameCardFlow} alt=\"NameCardFlow\"/>\n<br/>\n\n최근 WePLi에서 사용자의 취향이 반영된 명함을 생성하고 공유할 수 있는 기능을 개발하고 있었습니다.  \n\n이 기능은 사용자가 입력한 정보를 기반으로 명함을 즉시 생성하는 방식이었는데, 개발을 완료한 후 실제로 테스트해 보니 예상보다 밋밋한 느낌이 들었습니다.\n\n<br/>\n\n### ❓ 왜 그렇게 느껴졌을까?\n\n명함 생성 과정은 기술적으로 보면 완벽하고 단순했습니다.\n1. 사용자가 정보를 입력하고 버튼을 누르면,\n2. 미리 정의된 템플릿에 데이터를 채워서\n3. 바로 명함을 보여주면 끝.\n\n그런데 **사용 경험(UX)** 측면에서는 뭔가 부족함이 있었습니다.  \n\n입력한 정보들이 너무 빠르게 명함으로 변환되면서, 사용자는 **내가 무언가를 만들어낸 느낌**을 받지 못했습니다.\n어떤 데이터를 입력하든 순식간에 결과물이 나와버리니 감흥이 적었고, 그 과정에서 특별한 기대감도 형성되지 않았습니다.\n\n즉, 기능적으로는 문제가 없지만 UX적으로는 임팩트가 부족한 상태였습니다.\n이를 해결하기 위해 \"가짜 로딩\"을 추가해 사용자 경험을 개선할 수 있겠다는 생각을 하게 되었습니다.\n\n<br/>\n\n### 🤔 가짜 로딩을 추가하면 뭐가 좋을까?\n\n보통 로딩은 최대한 줄여야 하는 요소입니다. 하지만, 일부러 로딩을 추가하는 것이 UX 개선에 도움이 될 수도 있습니다.\n\n#### 1. 사용자의 기대감을 높인다.\n\n우리는 \"빠르면 좋다\"라고 생각하지만, 너무 빨리 끝나면 그만큼 감동도 덜합니다.  \n\n예를 들어, 영화에서 중요한 반전이 순식간에 지나가 버린다면 긴장감이 덜한 것처럼,\n**\"무언가 특별한 작업이 진행되고 있다\"** 는 느낌은 사용자에게 기대감을 갖게 만듭니다.\n\n명함을 만드는 동안 몇 초의 대기 시간은 기대감을 높이는 역할을 합니다.  \n**“어떤 명함이 나올까?“** 라는 궁금증이 UX를 더 깊이 있게 만들어 줍니다.\n\n#### 2. 명함이 단순한 데이터 조합이 아니라, 더 정교한 작업처럼 보이도록 만든다.\n\n기술적으로 보면 명함 생성은 즉시 끝낼 수 있습니다.\n하지만 사용자는 너무 빠르면 허술해 보인다고 느낄 수도 있습니다.  \n> 🤖 AI가 0.1초 만에 질문에 답변을 했다면 \"정확한 답변인가?\"라는 의문이 들지 않나요?\n\n<br/>\n가짜 로딩을 추가하면서 진행률을 실시간으로 보여준다면, 사용자는 \"내 명함이 좀 더 특별한 방식으로 만들어지고 있구나\"라고 인식하게 될 것 입니다.\n\n<br/>\n<br/>\n\n### ⏳ 총 로딩 시간 결정하기\n\n가짜 로딩을 통해서 사용자의 기대감을 향상시키는 것은 좋으나, 사용자를 지루하게 만들면 안됩니다.  \n즉, 의도적인 로딩을 추가할 때 **얼마나 오래 보여줄 것인가**를 정해야합니다.\n\n우선 사용자에게 답답함을 주지 않으면서 기대감을 심어줄 수 있는 최적의 시간을 찾기 위해 **로딩 시간에 따른 이탈률**에 관해 조사를 해보았습니다.\n\n\n<div align=\"center\" width=\"100px\">\n    <img src={LoadingGraph} alt=\"Loading\" style={{width: 450}} />\n    <p style={{ fontSize: \"0.85rem\", color: \"#6c757d\", textAlign: \"center\" }}>\n        로딩 시간에 따른 사용자 이탈률 (자료=Google / SOASTA Research, 2017)\n    </p>\n</div>\n\n\n- 1초 이하 : 사용자는 로딩을 거의 인지하지 못함. 기대감 상승 효과 없음\n- 1~2초 : 사용자가 \"무언가 생성되고 있다\"는 느낌을 받을 수 있는 최소한의 시간\n- 3초 이상 : 사용자가 로딩을 부담스럽게 느끼며, 3초를 넘어서면 이탈률이 급증하는 경향이 있음.\n\n자료에 따르면 로딩이 너무 짧으면 사용자가 충분히 인지하지 못하고, 너무 길면 지루함을 느껴 이탈할 수 있습니다.\n특히 3초 이상부터는 이탈률이 급격하게 증가합니다.  \n\n위의 조사롤 통해 처음에는 **최소 1초 이상, 3초 이내로 로딩을 유지하는 것이 적절**하다고 판단했습니다.  \n\n<br/>\n<br/>\n\n**🛠 초기 로딩 시간 설정 및 테스트**\n\n그래서 약 2초로 로딩 시간을 설정하고 개발을 진행한 후, 지인들을 대상으로 테스트를 진행해 보았습니다.\n\n<Admonition type=\"danger\" icon=\"🧑‍💻\" title=\"테스터들의 반응:\">\n- “생각보다 너무 빨리 끝나서, 로딩이 주는 임팩트가 약한 것 같다.”\n- “명함을 만드는 기능인데, 너무 짧아서 뭔가 휙 지나가 버리는 느낌이다.”\n</Admonition>\n\n👉 결론: 2초는 사용자에게 “명함이 만들어지고 있다”는 느낌을 주기엔 너무 짧음\n\n<br/>\n\n**🛠 3~4초로 조정 후 추가 테스트 진행**\n\n이후 로딩 시간을 3~4초로 조정하여 다시 테스트를 진행했습니다.\n\n<Admonition type=\"success\" icon=\"🧑‍💻\" title=\"테스터들의 반응:\">\n- “프로그레스 바가 실시간으로 올라가는 게 보여서 자연스러웠다.”\n- “숫자가 증가하는 애니메이션이 있어서 3~4초가 지루하게 느껴지진 않았다.”\n- “명함을 만드는 기능이라면, 이 정도 로딩 시간은 필요하다고 생각한다.”\n</Admonition>\n\n👉 결론: 3~4초 정도의 시간이 사용자가 ‘기다림’을 충분히 인식하면서도, 지루함을 느끼지 않는 최적의 시간으로 판단\n\n<br/>\n\n테스트 결과, 2초 이하는 기대감을 주기엔 너무 짧은 시간이었습니다.  \n애니메이션과 진행률 표시가 있더라도, **“명함이 만들어지는 과정”** 을 체감하기엔 부족했습니다.\n\n반면, **3초 ~ 4초** 정도의 로딩 시간을 적용했을 때는\n- 사용자가 충분히 ‘기다림’을 인식하면서도\n- 지루함을 느끼지 않는 최적의 경험을 제공할 수 있었습니다.\n\n결과적으로, 명함 만들기 기능의 가짜 로딩 시간은 약 **3초 ~ 4초**로 설정하였습니다.  \n\n<br/>\n<br/>\n\n### 🚀 로딩 애니메이션 설계\n\n가짜 로딩을 효과적으로 활용하려면 단순히 기다리는게 아니라, **자연스럽게 몰입할 수 있도록 설계하는 것이 중요**합니다.  \n잘못된 가짜 로딩은 오히려 사용자에게 **시간을 끌고 있다**는 인상을 줄 수 있기 때문에 주의해야합니다.\n\n이를 위해, 개발 전에 명확한 UX 요구사항을 정의하고, 이를 반영하여 로딩 애니메이션을 구현하였습니다.\n\n**📝 가짜 로딩 요구 사항**\n- 사용자가 로딩을 인지할 수 있어야한다.\n- 사용자가 지루함을 느껴서는 안된다.  \n   → 3초를 넘어서면 이탈률이 증가할 가능성이 있음  \n   → 적절한 애니메이션을 활용하면 체감 시간을 줄일 수 있음  \n- 사용자가 가짜 로딩인 것을 모르게 해야한다.  \n   → 일정하게 증가하는 것이 아닌 비선형적으로 증가해야함\n- 사용자가 현재 진행 상황을 명확하게 알 수 있어야한다.  \n   → 진행률을 표시해 예측 가능하게 만들어야 함\n\n\n**💡 구현 방법**\n- 3초 이전: 로딩 진행률을 랜덤하게 증가시키며, 일반적인 프로그레스 바처럼 동작\n- 3초 이후: 최소 증가량을 높여 빠르게 마무리하도록 조정\n- 딜레이를 랜덤하게 조정하여 불규칙한 진행 느낌을 줌  \n\n\n**📌 코드 구현 (비선형 증가 및 랜덤 딜레이 적용)**\n\n```kotlin\nwhile (state.makeCardProgress < 1.0f) {\n   val elapsedTime = System.currentTimeMillis() - startTime\n\n   reduce {\n      // 3초 이후에는 최소 증가량을 높여 더 빠르게 진행\n      val minIncrement = if (elapsedTime >= 3000L) 0.15 else 0.05\n      val randomIncrement = Random.nextDouble(minIncrement, 0.25).toFloat()\n      val progress = (state.makeCardProgress + randomIncrement)\n\n      state.updateProgress(progress)\n   }\n\n   // 3초 이후에는 딜레이를 줄여서 빠르게 마무리\n   val delayTime = if (elapsedTime >= 3000L) {\n      Random.nextLong(100L, 200L) // 3초 이후에는 짧은 딜레이 적용\n   } else {\n      Random.nextLong(250L, 750L) // 3초 이전까지는 기존 딜레이 유지\n   }\n\n   delay(delayTime)\n}\n```\n\n<br/>\n\n**🎭 UI 애니메이션 적용**\n> 프로그레스 바와 숫자가 자연스럽게 증가 되도록 하였습니다.\n\n```kotlin\nval animatedProgress by animateFloatAsState(\n   targetValue = state.makeCardProgress,\n   animationSpec = tween(durationMillis = 250, easing = LinearOutSlowInEasing),\n   label = \"Animated Progress\"\n)\n\nGradientLinearProgressBar(progress = animatedProgress)\n```\n\n<br/>\n<br/>\n<br/>\n\n### 🎯 결론: 가짜 로딩이 사용자 경험에 미치는 영향\n<img src={LoadingGif} alt=\"Loading\" style={{width: 200,  display: \"block\", margin: \"0 auto\"}} />  \n\n<br/>\n\n이번 경험을 통해 단순히 빠르게 결과를 보여주는 것이 최고의 UX가 아닐 수도 있다는 점을 다시금 확인할 수 있었습니다.  \n적절한 기다림은 사용자의 기대감을 높이고, 결과를 더욱 특별하게 느끼게 하는 요소가 될 수 있습니다.\n\n이제는 단순히 **“최대한 빠르게”** 가 아니라, **“사용자가 몰입할 수 있는 최적의 속도”** 를 고민하는 것이 중요한 시대인 것 같습니다.\n가짜 로딩이 단순한 시간 지연이 아니라, UX를 향상시키는 중요한 도구가 될 수 있다는 점을 기억하며 앞으로도 다양한 기능에 적용해볼 계획입니다.\n\n오늘도 긴 글 읽어주셔서 감사합니다. 😊"},{"id":"Apple Music API 사용기","metadata":{"permalink":"/blog/Apple Music API 사용기","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-12-29/2024-12-29.mdx","source":"@site/blog/2024-12-29/2024-12-29.mdx","title":"음악 API를 찾고 활용하기까지의 과정","description":"이 글에서는 WePLi에서 음악 API를 선택하고 활용한 과정을 소개합니다.","date":"2024-12-29T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"Apple Music API","permalink":"/blog/tags/apple-music-api"},{"inline":true,"label":"Spotify API","permalink":"/blog/tags/spotify-api"},{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app"}],"readingTime":6.595,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"Apple Music API 사용기","title":"음악 API를 찾고 활용하기까지의 과정","authors":["donghyeon"],"tags":["WePLi","Apple Music API","Spotify API","MusicApp"]},"unlisted":false,"prevItem":{"title":"가짜 로딩을 통해 사용자 기대감 향상시키기","permalink":"/blog/가짜 로딩을 활용하는 방법"},"nextItem":{"title":"WePLi를 개발하게 된 이유","permalink":"/blog/WePLi를 개발하게 된 이유"}},"content":"<!-- truncate -->\n\n이 글에서는 WePLi에서 음악 API를 선택하고 활용한 과정을 소개합니다.  \n특히 Apple Music API를 선택한 이유와 활용 예시를 중점으로 다룰 예정입니다.\n\n### 음악 데이터 구축의 필요성\n\n음악 관련 서비스에서 음악 검색 기능은 필수적인 요소입니다.  \n하지만 개인이 1억 개 이상의 곡과 지속적으로 추가되는 신곡 데이터를 직접 구축하는 것은 현실적으로 어렵습니다.\n\nWePLi의 초기 버전(Java Swing)에서는 여러 음악 플랫폼의 인기 차트를 통합하여 제공하는 기능을 고려했었습니다. 하지만 국내 플랫폼(멜론, 지니, 벅스 등)은 공식적인 API를 제공하지 않아, 크롤링을 이용해야 했습니다.\n\n<div align=\"center\">\n    ![검색 화면 예시](./wepli_chart_screen.png)\n    <p align=\"center\">\n        WePLi(Java Swing) 차트 화면\n    </p>\n</div>\n\n당시에는 서비스 배포 계획이 없었기 때문에 크롤링 방식이 문제가 되지 않았지만, 현재의 WePLi 앱은 공식적으로 배포될 예정이므로 안정적이고 법적 문제가 없는 공식 API가 필요했습니다.\n\n이 글에서는 음악 API를 선택하는 과정과 고려 사항을 정리하고, Apple Music API를 어떻게 활용했는지 소개하겠습니다.\n\n<br/>\n\n### 음악 API 선택 시 고려했던 것들\n\nWePLi는 단순 음악 검색 기능뿐만 아니라 사용자 간 공유, 게시글에 노래 첨부 등 다양한 기능을 제공합니다.\n이러한 기능을 구현하기 위해 적절한 음악 API를 찾기 시작했습니다.\n\n![검색 화면 예시](./search_screen.png)\n\n음악 API를 선택할 때 고려한 기준은 다음과 같습니다.\n\n- **필수 조건**\n   - 검색 기능 제공  \n   - 한국 노래 지원  \n   - 무료 또는 저렴한 비용\n   <br/>\n- **부가 조건**\n   - 추천 서비스 제공(검색어, 플레이리스트 등)  \n\n\n위 조건으로 API를 찾던 중, 가장 흔히 사용되는 API 서비스 2개가 눈에 들어왔습니다.\n\n- Spotify API [[링크]](https://developer.spotify.com/terms)\n- Apple Music API [[링크]](https://developer.apple.com/documentation/applemusicapi)\n\n<br/>\n\n### Spotify API vs Apple Music API 비교\n\n|                 |   Spotify   | Apple Music |\n|-----------------|-------------|-------------|\n| 검색 기능 제공 여부 | O            | O           |\n| 국내 노래 제공 여부 | X (영어로 제공) | O           |\n| 가격             | 무료          | 연 13만원     |\n\nSpotify API는 방대한 데이터와 무료라는 큰 장점이 있지만, 국내 노래가 한글로 지원 되지 않는다는 큰 단점이 있었습니다.\n아무래도 국내보단 해외에서 많이 사용되는 서비스이기 때문에 가수들이 노래를 등록할 때 영어로 등록을 많이 하는 것 같습니다.\n\n\n#### Spotify API의 단점\n1. 한국 노래가 영어로 등록되어 있음 -> 검색 및 사용자 경험 저하\n2. Spotify 로그인이 필수 -> Spotify를 사용하지 않는 유저에겐 허들로 느껴질 수 있음\n\nWePLi의 주요 타깃층은 **국내 트렌드에 민감한 10-20대** 사용자입니다.  \n10-20대가 주 타깃층인 앱에서 대부분의 노래가 영어로만 제공이 된다면 **앱의 매력이 크게 감소할 것**이라 판단했습니다.\n\n결과적으로 **조금 더 완성도 높은 사용자 경험을 제공하기 위해** 연 13만원의 비용을 지불하더라도 Apple Music API를 선택하였습니다.\n\n<br/>\n\n### Apple Music API 활용\n\nWePLi에선 Apple Music API를 활용하여 다음과 같은 기능을 구현했습니다.\n\n1. **음악 검색 기능**\n   - 사용자가 원하는 노래를 검색하면, Apple Music API에서 제목, 아티스트, 앨범, 썸네일 이미지 등을 가져옵니다.\n   - 검색 결과를 기반으로 사용자가 쉽게 곡을 추가하고 공유할 수 있도록 UI를 구성했습니다.\n   <br/>\n2. **인기 차트**\n   - Apple Music의 인기 차트 데이터를 가져와 실시간으로 트렌드 곡을 제공합니다.\n   - 사용자가 현재 인기 있는 곡을 쉽게 확인할 수 있도록 구현되었습니다.\n   <br/>\n3. **인기 검색어**\n   - Apple Music API를 활용해 사용자들이 많이 검색하는 키워드를 분석하여 제공하는 기능입니다.\n   - 이를 통해 사용자는 현재 유행하는 음악을 쉽게 찾을 수 있습니다.\n\n<br/>\n\n### 마무리\n\nWePLi는 사용자 경험을 최우선으로 고려하여 Apple Music API를 선택했습니다.  \n비용적인 부담은 있지만, 보다 완성도 높은 음악 검색 및 공유 기능을 제공할 수 있다는 점에서 충분히 가치 있는 선택이라고 판단했습니다.\n\n앞으로도 API를 활용한 기능을 확장하면서, 더 나은 사용자 경험을 제공할 계획입니다.  \n다음 글에서는 Apple Music API를 실제로 적용한 코드 및 구현 방법을 상세히 다뤄보겠습니다.\n\n긴 글 읽어주셔서 감사합니다 🎵"},{"id":"WePLi를 개발하게 된 이유","metadata":{"permalink":"/blog/WePLi를 개발하게 된 이유","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-12-28-WePLi를 개발하게 된 이유.mdx","source":"@site/blog/2024-12-28-WePLi를 개발하게 된 이유.mdx","title":"WePLi를 개발하게 된 이유","description":"음악은 단순히 듣는 것에서 그치지 않고, 사람들과의 연결과 감정을 공유하는 매개체로서 강력한 힘을 가집니다.","date":"2024-12-28T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app"}],"readingTime":4.395,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"WePLi를 개발하게 된 이유","title":"WePLi를 개발하게 된 이유","authors":["donghyeon"],"tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"음악 API를 찾고 활용하기까지의 과정","permalink":"/blog/Apple Music API 사용기"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"음악은 단순히 듣는 것에서 그치지 않고, 사람들과의 연결과 감정을 공유하는 매개체로서 강력한 힘을 가집니다.  \n그렇기에 저는 음악과 관련된 프로젝트를 통해 이런 가치를 담아내고 싶다는 열망을 품게 되었습니다.\n\n이 글에서는 **WePLi**를 개발하게 된 계기와 과정을 소개합니다.\n\n<!-- truncate -->\n\n<br/>\n\n### 음악과 관련된 프로젝트를 만들고 싶다는 열망\n\n음악은 항상 제 삶에서 큰 영감을 주는 요소였습니다.   \n특히 기존의 음악 앱들은 단순히 음악을 듣는 것을 넘어 사용자 경험과 트렌디한 디자인으로 저를 매료시켰습니다.\n\n이로 인해 **\"내가 만든 음악 앱은 어떤 모습일까?\"** 라는 생각이 자연스럽게 떠올랐고,   \n**WePLi** 프로젝트를 시작하는 계기가 되었습니다.\n\n<br/>\n\n### 디자인에 대한 욕심\n\n저는 개발자이지만, 늘 디자인에도 관심이 많았습니다.   \n기능적인 완성도는 기본이고, 이를 뒷받침하는 매력적인 디자인이야말로 프로젝트를 돋보이게 한다고 생각합니다.\n\n하지만 대학 시절 디자이너와 협업을 하면서 제 취향을 반영한 결과물을 만드는 것이 얼마나 어려운 일인지 깨달았습니다.   \n원하는 디자인을 말로 설명하는 것도 쉽지 않았고, 협업의 특성상 제 의견만을 고집할 수는 없었기 때문입니다.\n\n이후 회사에서도 기획서와 기존 디자인에 기반하여 개발을 진행하다 보니, 제가 **원하는 기능과 디자인을 온전히 담은 앱**을 만들어야겠다는 생각이 더욱 커져 **WePLi**를 개발하게 되었습니다.\n\n<br/>\n\n### 내 취향이 담긴 앱, WePLi의 탄생\n\n사실 **WePLi**라는 앱은 완전히 새로운 시작은 아니었습니다.   \n과거 Java Swing을 사용해 동일한 주제의 프로그램([Github](https://github.com/DeuWePLi/WePLi))을 만들어본 적이 있었습니다.\n\n\n당시에도 이 프로젝트는 제 취향을 가득 담아낸 결과물이라 큰 애정을 가졌었으나 기술적 한계로 인해 미완성으로 남겼던 아쉬움이 늘 마음에 남아 있었습니다.\n\n이번에는 성장한 제 개발 능력과 디자인 감각을 최대한으로 동원하여, 그때의 아쉬움을 해소하고 제가 진정으로 만들고 싶었던 앱을 완성하고자 WePLi를 시작했습니다.\n\n<br/>\n\n---\n\n**WePLi**는 단순한 앱이 아니라, 저의 개발 철학과 디자인에 대한 열정을 담은 프로젝트입니다.    \n음악이라는 주제를 통해 저만의 취향을 표현하면서도 사용자들에게 공감과 재미를 줄 수 있는 서비스를 만들고자 했습니다.\n\n앞으로 이 사이트를 통해 프로젝트를 완성하기까지의 과정과 시행착오 그리고 배운 점들을 기록하고 공유하고자 합니다.\n\n**WePLi**가 단순히 개인의 프로젝트를 넘어, 음악을 사랑하는 사람들이 서로의 취향을 공유하고 공감할 수 있는 공간이 되기를 바랍니다."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.465,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"WePLi를 개발하게 된 이유","permalink":"/blog/WePLi를 개발하게 된 이유"},"nextItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\n\nHere are a few tips you might find useful.\n\n<!-- truncate -->\n\nSimply add Markdown files (or folders) to the `blog` directory.\n\nRegular blog authors can be added to `authors.yml`.\n\nThe blog post date can be extracted from filenames, such as:\n\n- `2019-05-30-welcome.md`\n- `2019-05-30-welcome/index.md`\n\nA blog post folder can be convenient to co-locate blog post images:\n\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\n\nThe blog supports tags as well!\n\n**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."},{"id":"mdx-blog-post","metadata":{"permalink":"/blog/mdx-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-01-mdx-blog-post.mdx","source":"@site/blog/2021-08-01-mdx-blog-post.mdx","title":"MDX Blog Post","description":"Blog posts support Docusaurus Markdown features, such as MDX.","date":"2021-08-01T00:00:00.000Z","tags":[{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.235,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}],"frontMatter":{"slug":"mdx-blog-post","title":"MDX Blog Post","authors":["slorber"],"tags":["docusaurus"]},"unlisted":false,"prevItem":{"title":"Welcome","permalink":"/blog/welcome"},"nextItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).\n\n:::tip\n\nUse the power of React to create interactive blog posts.\n\n:::\n\n{/* truncate */}\n\nFor example, use JSX to create an interactive button:\n\n```js\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n<button onClick={() => alert('button clicked!')}>Click me!</button>"},{"id":"long-blog-post","metadata":{"permalink":"/blog/long-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-long-blog-post.md","source":"@site/blog/2019-05-29-long-blog-post.md","title":"Long Blog Post","description":"This is the summary of a very long blog post,","date":"2019-05-29T00:00:00.000Z","tags":[{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":2.06,"hasTruncateMarker":true,"authors":[{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"long-blog-post","title":"Long Blog Post","authors":"yangshun","tags":["hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"This is the summary of a very long blog post,\n\nUse a `<!--` `truncate` `-->` comment to limit blog post size in the list view.\n\n<!-- truncate -->\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"}],"blogListPaginated":[{"items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유","welcome","mdx-blog-post","long-blog-post"],"metadata":{"permalink":"/blog","page":1,"postsPerPage":10,"totalPages":1,"totalCount":6,"blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/blog/tags/we-p-li":{"inline":true,"label":"WePLi","permalink":"/blog/tags/we-p-li","items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유"],"pages":[{"items":["가짜 로딩을 활용하는 방법","Apple Music API 사용기","WePLi를 개발하게 된 이유"],"metadata":{"permalink":"/blog/tags/we-p-li","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/ui":{"inline":true,"label":"UI","permalink":"/blog/tags/ui","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/ui","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/ux":{"inline":true,"label":"UX","permalink":"/blog/tags/ux","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/ux","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/fake-loading":{"inline":true,"label":"Fake Loading","permalink":"/blog/tags/fake-loading","items":["가짜 로딩을 활용하는 방법"],"pages":[{"items":["가짜 로딩을 활용하는 방법"],"metadata":{"permalink":"/blog/tags/fake-loading","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/apple-music-api":{"inline":true,"label":"Apple Music API","permalink":"/blog/tags/apple-music-api","items":["Apple Music API 사용기"],"pages":[{"items":["Apple Music API 사용기"],"metadata":{"permalink":"/blog/tags/apple-music-api","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/spotify-api":{"inline":true,"label":"Spotify API","permalink":"/blog/tags/spotify-api","items":["Apple Music API 사용기"],"pages":[{"items":["Apple Music API 사용기"],"metadata":{"permalink":"/blog/tags/spotify-api","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/music-app":{"inline":true,"label":"MusicApp","permalink":"/blog/tags/music-app","items":["Apple Music API 사용기","WePLi를 개발하게 된 이유"],"pages":[{"items":["Apple Music API 사용기","WePLi를 개발하게 된 이유"],"metadata":{"permalink":"/blog/tags/music-app","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/facebook":{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description","items":["welcome"],"pages":[{"items":["welcome"],"metadata":{"permalink":"/blog/tags/facebook","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/hello":{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description","items":["welcome","long-blog-post"],"pages":[{"items":["welcome","long-blog-post"],"metadata":{"permalink":"/blog/tags/hello","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/docusaurus":{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description","items":["welcome","mdx-blog-post","long-blog-post"],"pages":[{"items":["welcome","mdx-blog-post","long-blog-post"],"metadata":{"permalink":"/blog/tags/docusaurus","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/blog/tags","authorsMap":{"donghyeon":{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/blog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"},"yangshun":{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"},"slorber":{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}}},"techblog":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"wepli-tech-blog-flow-grid","metadata":{"permalink":"/techblog/wepli-tech-blog-flow-grid","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/2025-04-08/flow_grid.mdx","source":"@site/techblog/2025-04-08/flow_grid.mdx","title":"Compose 반응형 앨범 그리드 구현하기 - LazyVerticalGrid 대신 FlowRow를 쓴 이유","description":"이 글에서는 다양한 화면 크기에 대응하는 앨범 그리드 UI를 Compose에서 어떻게 구현했는지 공유합니다.","date":"2025-04-08T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":11.76,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog-flow-grid","title":"Compose 반응형 앨범 그리드 구현하기 - LazyVerticalGrid 대신 FlowRow를 쓴 이유","authors":["donghyeon"],"date":"2025-04-08","tags":["WePLi","MusicApp"]},"unlisted":false,"nextItem":{"title":"Composable을 Bitmap으로 변환하는 방법","permalink":"/techblog/wepli-tech-blog-composable-to-bitmap"}},"content":"import FeatureScreenShot from './feature_capture.png';\nimport FlowRowImg from './flowrow.png';\nimport LayoutDocs from './layout.png';\nimport WindowSizeClass from './window_size_class.png';\n\n이 글에서는 다양한 화면 크기에 대응하는 앨범 그리드 UI를 Compose에서 어떻게 구현했는지 공유합니다.\n\n{/* truncate */}\n\n<br/>\n\nCompose를 통해 음악 정보 화면을 구현하면서, 마지막에 아티스트의 앨범을 그리드 형태로 보여주는 기능을 개발해야 했습니다.\n\n여기서 가장 중요하게 고려한 UX 요소는 **앨범 아이템의 크기가 너무 커지면 사용자가 부담스럽게 느낄 수 있다는 점**이었습니다.\n따라서 화면의 크기가 넓어질수록 그리드의 Span 수를 늘려 아이템이 항상 보기 편한 크기로 유지되도록 설계하고 싶었습니다.\n\n처음엔 간단히 LazyVerticalGrid를 사용하면 될 거라고 생각헀는데, 예상치 못한 문제가 발생하여 이 글을 쓰게 되었습니다.\n\n이 글에서는 반응형 앨범 그리드를 구현하면서 마주친 문제 상황과 이를 UX 관점에서 어떻게 고민하고 해결하였는지에 대한 과정을 공유하고자 합니다.\n\n### 기능 소개\n우선 먼저 구현하고 있는 기능은 음악 상세 정보 페이지입니다.\n\n<br/>\n<div align=\"center\">\n  <img src={FeatureScreenShot} alt=\"Loading\" style={{width: 600}}/>\n</div>\n\n<br/>\n\n페이지 하단에는 해당 가수의 다른 앨범들을 그리드 형태로 정리하여 보여주는 섹션이 있습니다.\n\n이처럼 그리드 형태의 UI를 사용하는 경우, 디바이스 화면 크기에 따라 아이템의 크기나 Span 수를 유동적으로 조절하는 것이 매우 중요합니다.\n\n특히 아이템이 너무 커지면 사용자가 부담스럽게 느낄 수 있기 때문에, **적절한 밀도로 앨범이 배치 되도록하는 것이 이번 UI/UX의 핵심**이었습니다.\n\n처음에는 간단히 LazyVerticalGrid를 사용하면 끝날 줄 알았습니다.\n하지만 막상 구현을 시작하자마자, 예상치 못한 제약에 부딪혔습니다.\n\n<br/>\n<br/>\n\n### 문제 상황: LazyVerticalGrid는 LazyColumn과 함께 쓸 수 없다.\n\n처음 구성한 구조는 아래와 같습니다.\n\n```kotlin\nColumn(\n    modifier = Modifier\n        .fillMaxSize()\n        .verticalScroll(scrollState)\n) {\n    // 기타 Component\n    LazyVerticalGrid(...) // 문제 발생 지점\n}\n```\n\n이처럼 LazyVerticalGrid를 스크롤 가능한 Column 내부에 넣었더니, 실행과 동시에 크래시가 발생하며 아래와 같은 에러 메시지가 출력 되었습니다.\n\n:::danger[Error]\n<b>IllegalStateException</b>\nNesting scrollable in the same direction layouts like LazyColumn and LazyVerticalGrid is not allowed.\n:::\n\n<br/>\n\n즉, **스크롤 가능한 레이아웃 안에 또 다른 Lazy 스크롤 레이아웃을 넣으면 안 된다**는 의미였습니다.\nCompose에서 스크롤 충돌을 방지하기 위해 이러한 구조를 제한하고 있습니다.\n\nLazyVerticalGrid 뿐만 아니라 LazyColumn(or Row) 내에 같은 방향의 스크롤 가능한 Component를 추가하면 동일한 크래시가 발생합니다.\n\n이후 여러 구조로 바꿔서 시도해도 결국 해결되지 않았습니다.\n이 문제를 해결하려면 **스크롤 충돌 없이도 그리드 레이아웃을 만들 수 있는 새로운 방법**이 필요했습니다.\n\n<br/>\n\n### 명확한 해결 방법을 찾기 위한 UI 요구사항 재정리\n\nLazyVerticalGrid를 대신할 방안을 찾기 위해 다시 한 번 UI 요구사항부터 명확히 정리해보기 시작했습니다.\n\n제가 구현하고자 하는 UI의 조건은 다음과 같았습니다.\n\n- 앨범 리스트를 그리드 형태로 보여줄 것\n- 앨범 아이템 크기는 화면 너비에 따라 동적으로 변할 것\n- 화면 너비에 따라 한 줄에 보여지는 앨범의 개수가 달라질 것\n  - ( 아이템의 크기가 너무 커지지 않게 조절하여 사용자가 부담을 느끼지 않는게 중요 )\n  - 일반적인 스마트폰 화면에선 한 줄에 2개\n  - 더 넓은 화면에선 한 줄에 4개\n- VerticalScroll이 가능한 레이아웃에서 사용 가능할 것\n\n위의 요구사항을 보면, 결국 자체적으로 스크롤을 관리하는 기능이 없으면서 그리드 형태를 표현할 수 있는 Component가 필요한 것을 알 수 있었습니다.\n\n<br/>\n\n### 요구사항을 기반으로 구현 로직을 고민하기\n\n위의 요구사항을 충족하기 위해 고려해야 할 사항은 다음과 같습니다.\n\n1. 화면의 너비에 따라 각 아이템의 너비를 동적으로 계산할 수 있어야 함\n2. 계산된 아이템의 너비를 기반으로 한 줄에 표시되는 아이템 수를 조정해야 함\n3. 최상위 Column 내에서 스크롤을 공유해야 하므로 자제적으로 스크롤을 처리하지 않는 컴포넌트가 필요함\n\n<br/>\n\n이 요구사항을 바탕으로 Compose의 **FlowRow**라는 Component를 떠올렸습니다.\n\n<div align=\"center\">\n  <img src={FlowRowImg} alt=\"Loading\" style={{width: 300}}/>\n</div>\n\n**FlowRow**는 아이템이 지정된 너비를 초과할 경우 자동으로 다음 줄로 넘어가는 Composable입니다.\n\n\n<br/>\n\n### FlowRow를 이용한 반응형 그리드 구현\n\n```kotlin\n@OptIn(ExperimentalMaterial3WindowSizeClassApi::class, ExperimentalLayoutApi::class)\n@Composable\nfun ResponsiveAlbumGrid(albums: List<AlbumUiData>, modifier: Modifier = Modifier) {\n    val activity = LocalActivity.current\n    val windowSizeClass = activity?.let { calculateWindowSizeClass(it) }\n\n    val spacing = 20.dp\n    val itemsPerRow = when (windowSizeClass?.widthSizeClass) {\n        WindowWidthSizeClass.Compact -> 2\n        WindowWidthSizeClass.Medium,\n        WindowWidthSizeClass.Expanded -> 4\n        else -> 2\n    }\n\n    BoxWithConstraints(modifier = modifier.fillMaxWidth()) {\n        val itemWidthPx = (maxWidth.toPx() - spacing.toPx() * (itemsPerRow - 1)) / itemsPerRow\n        val itemWidthDp = with(LocalDensity.current) { itemWidthPx.toDp() }\n\n        FlowRow(\n            modifier = Modifier.fillMaxWidth(),\n            maxItemsInEachRow = itemsPerRow,\n            horizontalArrangement = Arrangement.spacedBy(spacing),\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            albums.forEach { album ->\n                AlbumComponent(\n                    album = album,\n                    modifier = Modifier.width(itemWidthDp)\n                )\n            }\n        }\n    }\n}\n```\n\n#### 코드 설명\n- BoxWithConstraints로 현재 화면의 최대 너비(maxWitdh)를 측정합니다.\n- 화면 너비가 500dp 미만이면 한 줄에 2개, 그 이상이면 4개씩 표시합니다.\n- 각 앨범 아이템의 너비는 화면 너비와 아이템 간 간격(spacing)을 고려하여 동적으로 계산됩니다.\n\n\n<br/>\n\n### 개선 필요한 부분: 하드코딩된 값 피하기\n\n위의 코드로도 충분히 잘 동작하였으나, 한 가지 아쉬운 점이 있었습니다.\n화면의 크기를 결정하는 기준을 아래와 같이 하드코딩해서 구현하고 있습니다.\n\n```kotlin\nval isCompact = maxWidth < 500.dp\n```\n\n물론 지금 요구사항에서는 한 행에 보여지는 아이템이 사용자가 부담을 느낄 정도로 커지지만 않으면 되기 때문에 문제는 없습니다.\n\n그러나 기준도 애매하고 좋은 방법은 아닌 것 같아서 공식 문서를 찾아 보았습니다.\n\n<div align=\"center\">\n  <img src={LayoutDocs} alt=\"Loading\"/>\n  <p style={{ fontSize: \"0.85rem\", color: \"#6c757d\", textAlign: \"center\" }}>\n        <a href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive/support-different-screen-sizes?hl=ko&utm_source=chatgpt.com#explicit-layout-changes\">다양한 크기 지원 | Jectpack Compose | Android Developers</a>\n    </p>\n</div>\n\n역시나 공식 문서에서는 **레이아웃을 결정할 때 실제 하드웨어 값을 사용하지 말 것**을 권장하고 있었습니다.\n그 이유는 아래와 같습니다.\n\n:::info[Why]\n태블릿이나 Chrome OS 환경, 폴더블 기기, 멀티 윈도우 모드와 같이 화면 크기가 수시로 바뀔 수 있는 환경에서는 하드코디된 값이 제대로 대응하지 못할 수 있기 때문입니다.\n:::\n\n\n<br/>\n<br/>\n\n### 더 나은 해결책: WindowSizeClass 사용하기\n\n<div align=\"center\">\n  <img src={WindowSizeClass} alt=\"Loading\"/>\n  <p style={{ fontSize: \"0.85rem\", color: \"#6c757d\", textAlign: \"center\" }}>\n        <a href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive/use-window-size-classes\">Use window size classes | Jetpack Compose | Android Developers</a>\n    </p>\n</div>\n\nCompose에서는 화면 크기를 Compat, Medium, Expanded 3가지 상태로 구분하는 WindowSizeClass를 제공합니다.\n\n해당 클래스를 사용하면 하드코딩된 값 없이도 다양한 디바이스 환경에 맞는 레이아웃을 쉽게 구성할 수 있습니다.\n\n<br/>\n\n우선, 아래의 의존성을 추가해야 합니다.\n\n```kotlin\nimplementation(\"androidx.compose.material3:material3-window-size-class:1.2.1\")\n```\n\n<br/>\n\n아래는 실제 사용 예시입니다.\n\n```kotlin\n@Composable\nfun ResponsiveAlbumGrid(albums: List<AlbumUiData>) {\n    val activity = LocalContext.current as Activity\n    val windowSizeClass = calculateWindowSizeClass(activity)\n\n    val itemsPerRow = when (windowSizeClass.widthSizeClass) {\n        WindowWidthSizeClass.Compact -> 2\n        WindowWidthSizeClass.Medium -> 4\n        WindowWidthSizeClass.Expanded -> 6\n        else -> 2\n    }\n\n    val spacing = 20.dp\n\n    BoxWithConstraints(modifier = Modifier.fillMaxWidth()) {\n        val itemWidthPx = (maxWidth.toPx() - spacing.toPx() * (itemsPerRow - 1)) / itemsPerRow\n        val itemWidthDp = with(LocalDensity.current) { itemWidthPx.toDp() }\n\n        FlowRow(\n            modifier = Modifier.fillMaxWidth(),\n            maxItemsInEachRow = itemsPerRow,\n            horizontalArrangement = Arrangement.spacedBy(spacing),\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            albums.forEach { album ->\n                AlbumComponent(\n                    album = album,\n                    modifier = Modifier.width(itemWidthDp)\n                )\n            }\n        }\n    }\n}\n```\n\n\n#### WindowSizeClass 사용시 장점\n- Android가 정의한 표준을 따라 안정적으로 레이아웃을 설계할 수 있습니다.\n- 폴더블 기기, 태블릿, 멀티 윈도우 모드 등 다양한 디바이스 환경에 자연스럽게 대응됩니다.\n- 하드코딩된 값을 사용하는 것보다 훨씬 유지보수하기 쉽고 명확한 UI 구조를 만들 수 있습니다.\n\n\n<br/>\n\n### **마무리하며**\n\n결국, LazyVerticalGrid의 문제를 Compose의 FlowRow를 통해 깔끔하게 해결할 수 있었습니다.\n\n하드코딩된 기준점보다는 **WindowSizeClass를 활용하는 방식**이 더 나은 선택이라는 것도 함께 배울 수 있었습니다.\n\n<br/>\n<br/>\n<br/>\n\n#### 참고 문헌\n- [다양한 크기 지원 | Jectpack Compose | Android Developers](\"https://developer.android.com/develop/ui/compose/layouts/adaptive/support-different-screen-sizes?hl=ko&utm_source=chatgpt.com#explicit-layout-changes\")\n- [Use window size classes | Jetpack Compose | Android Developers](\"https://developer.android.com/develop/ui/compose/layouts/adaptive/use-window-size-classes\")\n- [Jetpack Compose Layout 적용기: 유연하고 성능이 개선된 화면을 구현하기까지](\"https://tech.wonderwall.kr/articles/composelayout/body/\")"},{"id":"wepli-tech-blog-composable-to-bitmap","metadata":{"permalink":"/techblog/wepli-tech-blog-composable-to-bitmap","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/2025-02-22/wepli-tech-blog-bitmap.mdx","source":"@site/techblog/2025-02-22/wepli-tech-blog-bitmap.mdx","title":"Composable을 Bitmap으로 변환하는 방법","description":"Composable을 Bitmap으로 변환하는 과정에서 발생한 이슈와 해결 과정에 대해 소개합니다.","date":"2025-02-22T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":10.72,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog-composable-to-bitmap","title":"Composable을 Bitmap으로 변환하는 방법","authors":["donghyeon"],"date":"2025-02-22","tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"Compose 반응형 앨범 그리드 구현하기 - LazyVerticalGrid 대신 FlowRow를 쓴 이유","permalink":"/techblog/wepli-tech-blog-flow-grid"},"nextItem":{"title":"Supabase Json으로 계층 구현하기","permalink":"/techblog/wepli-tech-blog-supabase-json"}},"content":"import NameCardFlow from './namecard_flow.png';\nimport NameCardDesign from './namecard_design.png';\nimport NameCardBlur from './namecard_blur.png';\nimport NameCardGif from './namecard_gif.gif';\n\nComposable을 Bitmap으로 변환하는 과정에서 발생한 이슈와 해결 과정에 대해 소개합니다.\n\n{/* truncate */}\n\n아래 글은 Jetpack Compose로 작성한 명함(또는 카드) UI를 이미지로 저장하고 공유하는 기능을 구현하면서 겪은 문제와 해결 과정을 정리한 글입니다.\n\nComposable → Bitmap 변환 과정과, 하드웨어 가속 / isLaidOut / 블러 등의 이슈에 대해 정리하였습니다.\n\n### 기능 소개\n\n<img src={NameCardFlow} alt=\"Loading\"/>\n\n<br/>\n\n현재 사용자의 음악 취향이 드러나는 명함을 생성할 수 있는 기능을 개발하고 있습니다.\n앱에서 생성한 명함은 이미지로 변환 되어 갤러리에 저장하거나, SNS로 공유할 수 있도록 할 예정이었습니다.\n\n기존 View 시절에는 drawToBitmap() 등으로 쉽게 처리했지만, Jetpack Compose로 UI를 작성하면 동일한 방식이 바로 적용되지 않아, 여러 문제를 해결해야 했습니다.\n\n<br/>\n\n### drawToBitmap()을 활용한 방식\n\n#### 초기 아이디어 💭 \n\n처음엔 Compose 내에 있는 Composable을 별도의 `ComposeView`에 그린 뒤, `drawToBitmap()`을 호출해서 Bitmap을 얻는 방식이었습니다.\n\n이 방법으로 간단하게 Composable을 Bitmap으로 변환할 수 있었으나 여러가지 이슈가 존재했습니다.\n\n#### 코드 예시\n\n```kotlin\n@Composable\nfun convertToBitmap(\n    targetContent: @Composable () -> Unit\n): () -> Bitmap? {\n    val context = LocalContext.current\n    val composeView = remember { ComposeView(context) }\n\n    fun captureBitmap(): Bitmap? {\n        // composeView가 아직 레이아웃되지 않았다면 null을 반환\n        return if (composeView.isLaidOut) {\n            composeView.drawToBitmap()\n        } else {\n            null\n        }\n    }\n\n    AndroidView(\n        factory = {\n            composeView.apply {\n                // 여기에서 targetContent를 실제로 그려주기\n                setContent { targetContent() }\n            }\n        }\n    )\n\n    // 필요한 시점에 captureBitmap()을 호출해 Bitmap을 얻음\n    return ::captureBitmap\n}\n```\n- convertToBitmap 함수는 별도 ComposeView를 생성해, 원하는 Composable(targetContent)를 그립니다.\n- 실제 뷰가 레이아웃을 마쳐야 drawToBitmap()을 안전하게 호출할 수 있으므로, isLaidOut 체크를 추가했습니다.\n\n<br/>\n\n:::info\n  **isLaidOut** 은 View(또는 ComposeView)가 레이아웃 과정을 모두 마쳐서 실제 화면 크기가 확정되었는지를 알려주는 플래그입니다.\n\n  이 값이 true여야 drawToBitmap() 등을 통해 안전하게 뷰를 Bitmap으로 변환할 수 있으며, 아직 레이아웃이 결정되지 않은 상태에서 캡처를 시도하면 **IllegalStateException**이 발생할 수 있습니다.\n:::\n\n<br/>\n\n이는 아래와 같이 호출할 수 있습니다.\n\n```kotlin\nval nameCardBitmapGenerator = convertToBitmap {\n    // Bitmap으로 변환할 Composable\n    NameCardComponent(nameCardInfo = state.nameCardInfo)\n}\n\n// 필요한 시점(예: 버튼 클릭 등)에 호출\nval bitmap: Bitmap? = nameCardBitmapGenerator.invoke()\n```\n\nBitmap 변환은 잘 되는 듯 했으나 하드웨어 가속 사용시 변환 불가한 이슈, Blur 미적용 이슈 등 여러 문제가 뒤따랐습니다.\n\n<br/>\n\n\n#### 1️⃣ 하드웨어 가속 사용시 변환 불가한 이슈\n  \nCoil을 사용해서 이미지를 로드하면 기본적으로 하드웨어 가속 옵션을 사용하게 됩니다.\n\n:::info\n```kotlin\nclass DefaultRequestOptions(\n    /*...*/\n    val allowHardware: Boolean = true,\n) \n```\nCoil의 DefaultRequestOptions 클래스를 보면 allowHardware 옵션의 기본 값이 true인 것을 알 수 있습니다.\n:::\n\n하드웨어 가속을 사용하는 상태에서 drawToBitmap()을 호출하면, 소프트웨어 Bitmap으로 직접 복사하기가 불가능해서 예외가 발생합니다.\n\n**해결** :   \n명함 생성 기능에서는 이미지를 대량으로 로드할 필요가 없었기에, 소프트웨어 가속을 사용하도록 설정을 변경했습니다.  \n성능 저하가 있을 수 있지만, 실제 명함 UI에서 이미지를 1~2장 정도만 다뤘으므로 영향이 크지 않았습니다.\n\n<br/>\n<br/>\n\n#### 2️⃣ Blur가 Bitmap으로 변환이 되지 않는 이슈\n\n두 번째 이슈는 Blur가 적용된 Composable을 캡쳐하면, Blur가 적용되지 않은 상태로 Bitmap이 추출된다는 점이었습니다.\n\n<div align=\"center\">\n  <img src={NameCardBlur} alt=\"Loading\" style={{width: 400}}/>\n</div>\n\n<br/>\n\n\n아래와 같이 여러 명함 디자인 중 Blur를 사용하는 케이스가 많았는데, 캡쳐 결과물에는 그 블러 효과가 전혀 나타나지 않아 난감했습니다.\n\n<img src={NameCardDesign} alt=\"Loading\"/>\n<br/>\n\n이를 해결하기 위해 Modifier.blur() 대신 다른 Blur 라이브러리(cloudy, haze) 등을 사용해봤는데도 문제는 동일했습니다.\n결국 Blur 자체의 문제라기보다는, 캡쳐 방법의 문제임을 알게 되었습니다.\n\n<br/>\n\n### graphicsLayer를 이용한 새로운 로직\n\n위 문제를 해결하기 위해, 공식 문서에서 안내한 graphicsLayer 기반의 캡쳐 방식을 도입했습니다.\n\ngraphicsLayer.toImageBitmap()를 사용하면, Blur가 GPU에서 처리되는 과정을 소프트웨어 버퍼로 기록할 수 있어 Blur가 적용된 상태를 보다 안정적으로 캡쳐할 수 있었습니다.\n\n```kotlin\nval graphicsLayer = rememberGraphicsLayer()\n\nNameCardComponent3(\n    nameCardInfo = state.nameCardInfo,\n    modifier = Modifier\n        .align(Alignment.CenterHorizontally)\n        .drawWithContent {\n            graphicsLayer.record {\n                this@drawWithContent.drawContent()\n            }\n            drawLayer(graphicsLayer)\n        }\n)\n\ngraphicsLayer.toImageBitmap()\n```\n\n#### Bitmap 변환\n\ngraphicsLayer.toImageBitmap()는 **ImageBitmap**을 반환하는데, 이를 곧바로 파일로 저장하거나 공유할 수는 없습니다.\n\n따라서 아래와 같은 확장 함수를 만들어, ImageBitmap → Bitmap 변환 과정을 거쳤습니다.\n\n```kotlin\nfun ImageBitmap.toAndroidBitmap(): Bitmap {\n    // 1. Compose의 PixelMap 가져오기\n    val pixelMap = this.toPixelMap()\n\n    // 2. PixelMap 크기에 맞는 빈 Bitmap 생성\n    val bitmap = Bitmap.createBitmap(pixelMap.width, pixelMap.height, Bitmap.Config.ARGB_8888)\n\n    // 3. PixelMap을 순회하며 Bitmap에 픽셀 쓰기\n    for (y in 0 until pixelMap.height) {\n        for (x in 0 until pixelMap.width) {\n            val color: Color = pixelMap[x, y]\n            bitmap.setPixel(x, y, color.toArgb())\n        }\n    }\n    return bitmap\n}\n```\n\n이렇게 최종적으로 Blur가 적용된 Bitmap을 얻을 수 있었습니다.\n\n:::info\ngraphicsLayer.toImageBitmap()는 suspend 함수이므로, Coroutine 내에서 호출해야 합니다.   \n또한 UI가 완전히 렌더링된 뒤에 호출해야 올바른 결과물을 얻을 수 있습니다.\n:::\n\n\n<br/>\n<br/>\n\n\n### BottomSheet에서 Bitmap 보여주기\n\n마지막으로, 생성된 Bitmap을 BottomSheet에 표시할 수 있게 구현하였습니다.\n\n#### 문제점\n- graphicsLayer.toImageBitmap()은 비동기(suspend) 로직입니다.\n- 따라서, 곧바로 BottomSheet를 열어버리면, Bitmap이 준비되지 않은 상태일 수 있습니다.\n\n#### 해결 방법\n1. 공유하기 버튼 클릭 시 -> Bitmap 생성 (graphicsLayer.toImageBitmap())\n2. Bitmap 생성이 완료되면 state로 저장\n3. BottomSheet에서는 미리 준비된 Bitmap을 안전하게 사용할 수 있음\n\n```kotlin\nvar nameCardBitmap by remember { mutableStateOf<ImageBitmap?>(null) }\n\nWepliBasicButton(\n    /*...*/\n    onClick = {\n        coroutineScope.launch {\n            // 사용자가 클릭한 시점에 Bitmap을 캡쳐\n            nameCardBitmap = captureNameCard(graphicsLayer)\n            sendAction(NameCardResultIntent.ShowShareBottomSheet(true))\n        }\n    },\n)\n\nif (state.isShownShareBottomSheet) {\n    nameCardBitmap?.let {\n        NameCardShareBottomSheet(nameCardBitmap = it, sendAction = sendAction)\n    }\n}\n```\n\n**동작 결과**\n\n<div align=\"center\">\n  <img src={NameCardGif} alt=\"Loading\" style={{width: 200}}/>\n</div>\n\n<br/>\n<br/>\n\n### 마무리\n\n이번 글에서는 Composable을 Bitamp으로 변환하고, 이를 저장하거나 공유하는 기능을 구현하면서 마주한 다양한 이슈들을 정리했습니다.\n\n- 하드웨어 가속이 켜진 이미지를 소프트웨어 비트맵으로 변환할 수 없는 문제\n- isLaidOut 플래그를 이용해 레이아웃이 완료된 뒤에만 캡처해야 하는 이슈\n- Blur가 전혀 반영되지 않고 원본 상태로 캡처되는 문제\n- graphicsLayer.toImageBitmap()가 suspend 함수이므로, UI 흐름(예: BottomSheet)과의 타이밍을 잘 맞춰야 하는 점\n\n\n이러한 문제들을 해결하는 과정에서,\n\n1. 소프트웨어 가속 사용\n2. isLaidOut 체크 후 안전한 시점에 drawToBitmap() 호출\n3. Blur 효과를 살리기 위한 graphicsLayer 활용\n4. 코루틴을 통한 비동기 처리와 UI 제어(예: BottomSheet 열기 시점 조정)\n\n등을 적용했습니다.\n\nCompose가 반복 렌더링(Recomposition)을 통해 UI를 효율적으로 그려주는 장점이 있지만, 이미지 캡쳐처럼 **정확한 시점**과 **렌더링 타입**을 제어해야 하는 기능은 기존 View 대비 고려해야 할 요소들이 많은 것 같습니다.\n\n이번 경험을 통해 쌓은 노하우가, 앞으로 다양한 UI 개발에 있어 큰 도움이 될 것이라 기대합니다.\n\n끝까지 읽어주셔서 감사하며, 앞으로도 Compose 기반 앱 개발에서 발생하는 이슈들을 공유하여, 같은 문제로 고민하는 분들께 도움이 되길 바랍니다.\n\n<br/>\n\n---\n\n#### Reference\n- [Android 공식 문서 - Graphics modifiers](https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#composable-to-bitmap)\n- [StackOverflow - Convert a composable view into image in Jetpack Compose](https://stackoverflow.com/questions/74450838/convert-a-composable-view-into-image-in-jetpack-compose)"},{"id":"wepli-tech-blog-supabase-json","metadata":{"permalink":"/techblog/wepli-tech-blog-supabase-json","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/2025-02-01/wepli-tech-blog-supabase-json.mdx","source":"@site/techblog/2025-02-01/wepli-tech-blog-supabase-json.mdx","title":"Supabase Json으로 계층 구현하기","description":"Supabase를 사용하면서 View를 사용했을 때의 문제점을 소개합니다.","date":"2025-02-01T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":7.405,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog-supabase-json","title":"Supabase Json으로 계층 구현하기","authors":["donghyeon"],"date":"2025-02-01","tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"Composable을 Bitmap으로 변환하는 방법","permalink":"/techblog/wepli-tech-blog-composable-to-bitmap"},"nextItem":{"title":"WePLi 기술 블로그 소개","permalink":"/techblog/wepli-tech-blog"}},"content":"import RdbImage from './rdb.png';\n\nSupabase를 사용하면서 View를 사용했을 때의 문제점을 소개합니다.\n\n<br/>\n<br/>\n{/* truncate */}\n\nWePLi는 현재 서버 프레임워크 없이 Supabase만을 활용해 개발 중입니다.  \n\nSupabase는 서버가 없는 동안 임시 대체제로 사용되고 있으며, 추후 실제 서버로 전환할 예정입니다.  \n**Supabase를 서버로 전환할 때 앱에는 최대한 영향이 없어야한다는 목표**를 가지고 개발에 임하고 있습니다.\n\n앱에 영향이 없으려면 Supabae에서 실제 서버의 응답 구조와 비슷하게 구성을 해야하는데,  \n여기서 한 가지 문제점이 존재합니다.  \n\n<br/>\n<div align=\"center\">\n  <img src={RdbImage} alt=\"Loading\" style={{width: 400}}/>\n</div>\n<br/>\n\n관계형 데이터베이스는 기본적으로 **평면적인 테이블 구조**를 사용하기 때문에 **계층 데이터를 표현하기 어렵습니다.**  \n이로 인해 Supabase의 응답 형식과 실제 서버의 응답 구조 사이에 차이가 발생하며, 이 차이가 클수록 실제 서버 전환 시 앱 코드 수정 사항이 많아집니다.\n\n이 글에서는 기존 View 방식의 한계와, **PostgreSQL**의 ***JSON Aggregation*** 기능을 활용하여 계층형 데이터 뷰를 구성하는 방법을 소개합니다.\n\n<br/>\n\n### 기존 View 생성 방식과 그 한계\n\n일반적으로 View를 생성할 때는 여러 테이블을 JOIN하여 단순한 평면(Flat) 구조의 데이터를 반환합니다.\n\n예를 들어, **게시글(post)** 에 **작성자(user)** 와 **수록곡(song)** 정보를 함께 포함시키는 경우, 아래와 같이 View를 정의할 수 있습니다.\n\n```sql\nCREATE VIEW post_view AS\n  SELECT\n    p.id AS post_id,\n    p.title AS post_title,\n    p.contents AS post_contents,\n    u.id AS post_author_id,\n    u.email AS post_author_email,\n    u.username AS post_author_nickname,\n    u.profile_img AS post_author_profile_img,\n    s.song_id AS song_id,\n    s.title AS song_title,\n    s.artist_name AS song_artist,\n    s.album AS song_album,\n    s.cover_img AS song_cover,\n    s.href AS song_href,\n    s.duration_millis AS song_duration\nFROM posts p\n  LEFT JOIN public.user u ON p.author = u.id\n  LEFT JOIN post_bside_track pbt ON p.id = pbt.post_id\n  LEFT JOIN song s ON pbt.song_id = s.id;\n```\n\n<br/>\n\n### 주요 문제점\n\n1. 계층적 데이터 표현의 부재\n\n    ![image](./image_1.png)\n\n    - 게시글 하나에 여러 수록곡(song)이 포함되어 있으면, 각각의 수록곡마다 게시글 정보가 반복되어 반환됩니다.  \n      예시) 게시글 1에 수록곡 3개가 있다면, 동일한 게시글 정보가 3번 반복됨\n\n\n2. 네트워크 사용량 증가\n    - 데이터가 중복되어 전송되므로, 네트워크 사용량과 클라이언트 메모리 부담이 증가하며, 안드로이드 앱에서 파싱 및 가공하는 과정이 복잡해집니다.\n\n3. 서버 마이그레이션 및 API 변경 시 추가 공수 발생\n    - 서버 API는 일반적으로 계층적 구조로 데이터를 제공하므로, 이후 실제 서버로 마이그레이션시 수정이 불가피합니다.\n\n<br/>\n\n### Json Aggregation을 활용한 계층형 View 생성 방식\n\n관계형 DB에서 계층 구조로 데이터를 표현하는 방법 중 하나는 JSON을 이용하는 것입니다.\n\nPostgreSQL의 JSON 함수(json_agg, json_build_object)를 활용하면 데이터베이스에서 미리 계층형 구조의 데이터를 만들어 클라이언트에 전달할 수 있습니다.\n\n#### 구현 예시\n\n아래 코드는 각 게시글에 포함된 수록곡 정보를 JSON 배열로 집계하여, 게시글과 작성자 정보와 함께 계층형 데이터를 반환하는 View를 생성하는 예시입니다.\n\n```sql\nCREATE OR REPLACE VIEW post_tree_view as\n  WITH song_agg AS (\n    SELECT\n      pbt.post_id,\n      json_agg(\n        json_build_object(\n          'song_id', s.id,\n          'title', s.title,\n          'artist_name', s.artist_name,\n          'album', s.album,\n          'cover_img', s.cover_img,\n          'href', s.href,\n          'duration_millis', s.duration_millis\n        )\n      ) AS song_list\n    FROM post_bside_track pbt\n    LEFT JOIN song s ON pbt.song_id = s.id\n    GROUP BY pbt.post_id\n  )\n  SELECT\n    p.id AS post_id,\n    p.title AS post_title,\n    p.contents AS post_contents,\n    json_build_object(\n      'id', u.id,\n      'email', u.email,\n      'username', u.username,\n      'profile_img', u.profile_img\n    ) AS \"user\",\n    COALESCE(s.song_list, '[]'::json) AS song_list\n  FROM posts p\n  LEFT JOIN public.user u ON p.author = u.id\n  LEFT JOIN song_agg s ON p.id = s.post_id;\n\n```\n\n\n**실제 출력 결과**\n\n![image.png](./image_2.png)\n\n리스트 형태의 데이터가 Json으로 하나의 필드에 포함된 것을 볼 수 있습니다.  \n이렇게 불필요한 데이터 반복을 줄이고 필요한 데이터만 출력이 가능합니다.\n\n**예시 응답 결과**\n\n```json\n{\n  \"post_id\": 1,\n  \"post_title\": \"게시글 제목\",\n  \"post_contents\": \"게시글 내용\",\n  \"user\": {\n     \"id\": 123,\n     \"email\": \"user@example.com\",\n     \"username\": \"작성자닉네임\",\n     \"profile_img\": \"이미지 URL\"\n  },\n  \"song_list\": [\n     {\n       \"song_id\": 10,\n       \"title\": \"노래 제목\",\n       \"artist_name\": \"아티스트 이름\",\n       \"album\": \"앨범명\",\n       \"cover_img\": \"커버 이미지 URL\",\n       \"href\": \"노래 링크\",\n       \"duration_millis\": 210000\n     },\n     ...\n  ]\n}\n```\n\n<br/>\n\n### 안드로이드 입장에서의 Json 기반 View 활용 장점\n\n1. 네트워크 효율성 (데이터 전송 최적화)\n    - 중복 데이터 전송이 줄어들어 데이터 사용량이 절감됨\n    - 네트워크 비용 측면(데이터 사용량)에서도 효율적\n\n2. 응답 매핑 로직 간소화\n    - Domain 모델의 구조와 API 응답 구조가 비슷할수록 매핑 로직이 간소화 됨\n    - 평면 데이터에서 계층 구조로의 재구성이 필요 없으므로 개발 생산성이 향상됨\n\n3. 유지보수 및 확장성\n\t- 서버 API 변경이나 마이그레이션 시, 계층형 데이터 구조를 유지함으로써 클라이언트 코드 변경 부담이 줄어듦\n\n\n<br/>\n\n### 결론\n\nSupabase와 PostgreSQL의 JSON Aggregation 기능을 활용하여 계층형 데이터를 미리 구성함으로써, 안드로이드 앱 개발에서 네트워크 최적화 및 클라이언트 로직 단순화라는 이점을 얻을 수 있었습니다.\n\n서버 대신 Supabase를 이용해서 개발을 하시는 분들이 있다면 해당 글을 참고해서 활용해보시면 좋을 것 같습니다."},{"id":"wepli-tech-blog","metadata":{"permalink":"/techblog/wepli-tech-blog","editUrl":"https://github.com/facebook/docusaurus/edit/master/website/my-blog/techblog/intro.mdx","source":"@site/techblog/intro.mdx","title":"WePLi 기술 블로그 소개","description":"해당 블로그는 WePLi 개발 과정 중 기술적인 부분에 대해서 작성하기 위한 페이지입니다.","date":"2024-12-31T00:00:00.000Z","tags":[{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li"},{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app"}],"readingTime":0.475,"hasTruncateMarker":true,"authors":[{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}],"frontMatter":{"slug":"wepli-tech-blog","title":"WePLi 기술 블로그 소개","authors":["donghyeon"],"date":"2024-12-31","tags":["WePLi","MusicApp"]},"unlisted":false,"prevItem":{"title":"Supabase Json으로 계층 구현하기","permalink":"/techblog/wepli-tech-blog-supabase-json"}},"content":"해당 블로그는 WePLi 개발 과정 중 기술적인 부분에 대해서 작성하기 위한 페이지입니다.\n\n개발 과정에 대한 내용 및 이슈 해결 과정 등을 기록하기 위한 블로그입니다.\n\n그외 프로젝트 및 기획, UI/UX 등에 관한 내용은 Blog 탭에서 확인 할 수 있습니다.\n{/* truncate */}"}],"blogListPaginated":[{"items":["wepli-tech-blog-flow-grid","wepli-tech-blog-composable-to-bitmap"],"metadata":{"permalink":"/techblog","page":1,"postsPerPage":2,"totalPages":2,"totalCount":4,"nextPage":"/techblog/page/2","blogDescription":"Blog","blogTitle":"Blog"}},{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog/page/2","page":2,"postsPerPage":2,"totalPages":2,"totalCount":4,"previousPage":"/techblog","blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/techblog/tags/we-p-li":{"inline":true,"label":"WePLi","permalink":"/techblog/tags/we-p-li","items":["wepli-tech-blog-flow-grid","wepli-tech-blog-composable-to-bitmap","wepli-tech-blog-supabase-json","wepli-tech-blog"],"pages":[{"items":["wepli-tech-blog-flow-grid","wepli-tech-blog-composable-to-bitmap"],"metadata":{"permalink":"/techblog/tags/we-p-li","page":1,"postsPerPage":2,"totalPages":2,"totalCount":4,"nextPage":"/techblog/tags/we-p-li/page/2","blogDescription":"Blog","blogTitle":"Blog"}},{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog/tags/we-p-li/page/2","page":2,"postsPerPage":2,"totalPages":2,"totalCount":4,"previousPage":"/techblog/tags/we-p-li","blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/techblog/tags/music-app":{"inline":true,"label":"MusicApp","permalink":"/techblog/tags/music-app","items":["wepli-tech-blog-flow-grid","wepli-tech-blog-composable-to-bitmap","wepli-tech-blog-supabase-json","wepli-tech-blog"],"pages":[{"items":["wepli-tech-blog-flow-grid","wepli-tech-blog-composable-to-bitmap"],"metadata":{"permalink":"/techblog/tags/music-app","page":1,"postsPerPage":2,"totalPages":2,"totalCount":4,"nextPage":"/techblog/tags/music-app/page/2","blogDescription":"Blog","blogTitle":"Blog"}},{"items":["wepli-tech-blog-supabase-json","wepli-tech-blog"],"metadata":{"permalink":"/techblog/tags/music-app/page/2","page":2,"postsPerPage":2,"totalPages":2,"totalCount":4,"previousPage":"/techblog/tags/music-app","blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/techblog/tags","authorsMap":{"donghyeon":{"name":"Donghyeon Kim","title":"Android Developer @Cashwalk","url":"https://github.com/dongx0915","page":{"permalink":"/techblog/authors/donghyeon"},"socials":{"github":"https://github.com/donghyeon0915","blog":"https://dongx2.tistory.com/"},"imageURL":"https://avatars.githubusercontent.com/u/63500239?v=4","key":"donghyeon"}}}},"docusaurus-plugin-content-pages":{"default":[{"type":"jsx","permalink":"/","source":"@site/src/pages/index.tsx"},{"type":"mdx","permalink":"/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don't need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-theme-classic":{},"docusaurus-tailwindcss":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}